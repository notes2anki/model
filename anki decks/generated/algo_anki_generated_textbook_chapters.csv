"Chapter 1: Linear Search
- Linear Search Overview: This section provides an overview of the linear search algorithm, which is used to find an item in an (un)sorted list. It explains how the algorithm starts at the first item and checks each item one by one. It also discusses the efficiency of linear search for smaller data sets and its limitations for large data sets.
- Applications of Linear Search: Here, we explore the practical applications of linear search, such as finding items in small data sets and searching unordered data. We discuss how linear search can be used for tasks like find and replace function in a word processor and why it is the easiest search algorithm to implement but usually the most inefficient.
- Linear Search Pseudocode: This section provides a step-by-step explanation of the linear search algorithm using pseudocode. It covers the initialization of variables, the main while loop, and the condition to exit the loop when the item is found or the entire data set has been searched.
- Linear Search Algorithm Must: This subsection highlights the key requirements of a linear search algorithm. It explains that the algorithm must be able to locate an item in a data set regardless of its order and run without crashing even if the item doesn't exist. Furthermore, it emphasizes the sequential check of each item starting from the first item.
- Limitations of Coded Linear Search: In this subsection, we discuss the limitations of the coded linear search algorithm. Specifically, we address the issue of exiting as soon as the first occurrence of the item is found. We also raise the question of what to do if we want to find the first, last, or all occurrences.","[Front: Linear Search overview Back: Finds an item in a(n) (un)sorted list. Starts at the first item and checks each item one by one. Doesn't required the data set to be in order Can be efficient for smaller data sets Inefficient for large data sets],
[Front: Applications of linear search Back: Ideal for finding items in small data sets and searching unoredered data such as a settings file. Typical use of linear search would be a find and replace function in a word processor Easiest search algorithm to implement but usually most inefficient.],
[Front: Linear search psuedocode Back: found  = False index = 0  # start by initialising variables with their starting state. # ""found"" Boolean value is used to indicate whether the item we are searching fro has been found or not - start with False. # ""index"" specifies current position in the data set, starting at 0, we will assume the data being searched is stored in array or list. While found == False and index < items.Length #We enter a While loop that will continue to execute while found is False and index is less than the lengh of the items list.            If items[index] == itemToFind then #Each time around the loop, the program checks to see if the current item is the one we are searching for.                found = True #if it is, then Found is set to true causing the exit of the loop at the start of next iteration            Else                index = index + 1 #if it isn't then increment index by 1, meaning next iteration of the loop, the program will be checking against the next location the data set.            End IF  End While],
[Front: Linear search psuedocode without comments Back: found = False index = 0   While found == False and index < items.Length            If items[index] ==  itemToFind then                found = True            Else                index = index + 1            End If End While],
[Front: Linear search algorithm must: Back: Be able to locate an item in a data set if it exists Be able to locate the item regardless of whether the data set is sorted or not. Run without crashing even if the item being searched for doesn't eexist in the data set. Check each item sequentially starting with the first item.],
[Front: Limitations of coded linear search: Back: Version exits as soon as the first occurence of the item is found What if you wanted to find the first, last or all occurences?]"
"Chapter 2: Binary Search
- Binary Search Overview: This section provides an overview of the binary search algorithm, which is more efficient than linear search for finding an item in a sorted data set. It explains how binary search starts at the middle of the list and repeatedly divides the list in half. It also highlights the requirement of the data set being sorted first and the efficiency of binary search for large data sets.
- Applications of Binary Search: Here, we explore the practical applications of binary search, focusing on its usefulness for searching for items in large sorted data sets. We discuss scenarios like online dictionaries where words are sorted in alphabetical order, and how binary search quickly reduces the search space for very large data sets.
- Binary Search Pseudocode: This section provides a step-by-step explanation of the binary search algorithm using pseudocode. It covers initializing variables, the main while loop, and the comparison-based logic to determine the next search space based on the midpoint of the data set.
- Bubble Sort Overview: This subsection introduces the bubble sort algorithm, which is used to sort an unordered list of items by comparing each item with the next one and swapping items if they are out of order. It explains how bubble sort works by bubbling the largest or smallest item to the end of the list in each pass.
- Applications of Bubble Sort: In this subsection, we discuss th","[Front: Binary search overview Back: Efficient algorithm for finding an item in a sorted data set. More efficient than linear search. Starts at the middle of the list and repeatedly divides the list in half Requires the data set to be sorted first e.g. numerical or alphabetical order Efficient for large data sets],
[Front: Applications of binary search Back: Ideal when you need to search for an item in a large sorted data set e.g.  online dictionary where words are sorted in alphabetical orderAs it discards half of the data after each iteration, it quickly reduces the very large data sets containing millions of records to one much more manageable.],
[Front: Psuedocode binary search Back: found = False first  =  0 last = items.length - 1 #found is used to indicate whether the item we are searching for has been found or not- seting it to false #first/last: with each iteration, we need to know the curretn index of the first and last item in data set so we can find the mid point. MP changes with each iteration. To start with, we will be searching the entire data set, so set ""first"" to index 0 and ""last"" to length of data set - 1 which will be the index of the last item.  While first <= last and found == False #Enter a while loop that continue to iterate providing both first <= last and found == False. Loop will iterate until item is found or entire data set has been searched.       midpoint = (first + last) DIV 2 #Calculate the MP of data set. Add index values in ""first"" and ""last"" and do floor division to get an integer.       IF items[midpoint] == itemToFind then #Each iteration, program checks if the item at the MP of the data set is the one we are searching for.           found = True #if it is, ""found"" is set to True and loop will exit at the start of the nnext iteration       Else           If items[midpoint] < itemToFind then #if not then program will check if the MP is less than or greater than the desired item, allowing us to discard half the entire data set. We can do this becuase items in the data set of a binary search are stored in order.              first = midpoint + 1 #if item at MP is less than the desired value, we adjust ""first"" to point at the index value in MP + 1           Else               last = midpoint = 1 #if item at MP is more than the desired value, we adjust ""last"" to point at the index value in MP - 1 #Repeat while loop until we find desired item or prove that item is not in data set.           End If        End If End While],
[Front: Binary seach psuedocode without comments Back: found = False first = 0 last = items.Length -1  WHILE first <= last and found == False         midpoint = (first+last) DIV 2         IF items[midpoint] == itemToFind then             Found = True         Else           IF items[midpoint] < itemToFind then               first = midpoint + 1           Else                last = midpoint - 1           End IF         End If End While],
[Front: Bubble sort overview: Back: Sorts an unordered list of items by comparing each item with the  next one and swapping the items if it is greater than it. Algorithm is finished when no more swaps can be made. It bubbles the largest or smallest up to the end of the list. Last element will be in correct place after first pass.],
[Front: Applications of bubble sort Back: Most inefficient sorting algorithm Easy to implement Popular choice for very small data sets Ideal for situations where a simple easy to program sorting  algorithm is required.],
[Front: Bubble sort psuedocode Back: n = items.length swapped  = True # ""n"" used to track how far through the data set we need to check for items to swap on each iteration. start by setting it to then length of the data set.  #""swapped"" used to indicate whether a swap has taken place each iteration of the inner for loop. start by setting it to true so we will enter the main WHILE loop at least once to check for unsorted items. WHILE n > 0 AND swapped == True #enter a while loop which will iterate while n>0 and swapped == True. Loop will iterate until all items are sorted           swapped = False #each iteration the while loop assumes there are no items that need to be swapped until we prove otherwisw, so we set ""swapped"" to false.           n = n -1 #ensures that the length of the list is inline with 0 indexing. Ensures that the entire data set will be checked the first iterations for items to swap. This value will decrement by 1 each iteration of the outer WHILE loop. Sorted items will gradually, bubble up to the end of the data set so there will be fewer items to check through each iteration.           For index = 0 To n-1 #nested inner for loop. for each pass through the data set, respresented by the while loop, we need to start through the beginning and work through to the penultimate item of the unsorted data set, represented by n - 1. Need to work through the current subset of items that still need to be check.                If items[index] > items[index+1] then #if we find that the item at the current location in the data set is greater than the next item, we know it is out of order                    Swap(items[index] , items [index+1])                    swapped = True #we then swap the 2 items, then set ""swapped"" to true so that when we next check the outer while loop, we know we are still in the process of sorting the data out.                  End IF            End For #continue through the data set moving the item up as far as it needs to go until it is in the correct place. End WHILE #process is repeated as many times necessary until we discover the entire data set has been sorted.],
[Front: bubble sort pseudocode without comments Back: n = items.Length swapped = True  While n > 0 AND swapped == True           swapped = False           n = n -1           For index = 0 TO n-1                  If items[index] > items[index+1] then                     Swap(items[index] , items[index+1])                     swapped = True                 End if           End For End While],
[Front: Insertion sort overview: Back: Inserts each item into its correct position in a data set one at a  time. Useful for small data sets. Partically useful for inserting items into a ready sorted list Inefficient for larger data sets.]"
":
Chapter 1: Linear Search
- Linear Search Overview: This section provides an overview of the linear search algorithm, which is used to find an item in an (un)sorted list. It explains how the algorithm starts at the first item and checks each item one by one. It also discusses the efficiency of linear search for smaller data sets and its limitations for large data sets.
- Applications of Linear Search: Here, we explore the practical applications of linear search, such as finding items in small data sets and searching unordered data. We discuss how linear search can be used for tasks like find and replace function in a word processor and why it is the easiest search algorithm to implement but usually the most inefficient.
- Linear Search Pseudocode: This section provides a step-by-step explanation of the linear search algorithm using pseudocode. It covers the initialization of variables, the main while loop, and the condition to exit the loop when the item is found or the entire data set has been searched.
- Linear Search Algorithm Must: This subsection highlights the key requirements of a linear search algorithm. It explains that the algorithm must be able to locate an item in a data set regardless of its order and run without crashing even if the item doesn't exist. Furthermore, it emphasizes the sequential check of each item starting from the first item.
- Limitations of Coded Linear Search: In this subsection, we discuss the limitations of the coded linear search algorithm. Specifically, we address the issue of exiting as soon as the first occurrence of the item is found. We also raise the question of what to do if we want to find the first, last, or all occurrences.

Set 2:
Chapter 2: Binary Search
- Binary Search Overview: This section provides an overview of the binary search algorithm, which is more efficient than linear search for finding an item in a sorted data set. It explains how binary search starts at the middle of the list and repeatedly divides the list in half. It also highlights the requirement of the data set being sorted first and the efficiency of binary search for large data sets.
- Applications of Binary Search: Here, we explore the practical applications of binary search, focusing on its usefulness for searching for items in large sorted data sets. We discuss scenarios like online dictionaries where words are sorted in alphabetical order, and how binary search quickly reduces the search space for very large data sets.
- Binary Search Pseudocode: This section provides a step-by-step explanation of the binary search algorithm using pseudocode. It covers initializing variables, the main while loop, and the comparison-based logic to determine the next search space based on the midpoint of the data set.
- Bubble Sort Overview: This subsection introduces the bubble sort algorithm, which is used to sort an unordered list of items by comparing each item with the next one and swapping items if they are out of order. It explains how bubble sort works by bubbling the largest or smallest item to the end of the list in each pass.
- Applications of Bubble Sort: In this subsection, we discuss th","[Front: Insertion sort psuedocode Back: For index = 1 TO items.Length: #algorithm sets a for loop to iterate through the data set #it compares the item in items[1] with item immediately before it, at items[0]. This is why the for loop starts at 1 not 0, if we started at 0, we would be trying to compare the very first item in the data set with one at position items [-1] which would cause an out of bounds error.        current = items[index] #first thing we do each iteration is take a copy of item we are sorting and place it in temporary ""current"". We do this because if we  find items before it are wrong order, we will need to move them  up in the data set. In doing this we would override the original  term and we need a way of getting back to insert it into its current location.        index2 = index #set index2 to be same value as index 1. index2 used to track where we need to exit inner While loop. Every iteration of outer FOR loop, we need to check the current item against items before it. As we iterate through the data set, this number increases.          While index2 > 0 AND items[index2-1] > current #inner while loop is executed if any additional items before the one one we are comparing that still needs to be checked with index2 > 0 AND we check if that the item is greater than the one we are comparing, if it is, then we know the items are out of place.                items[index2] = items[index2 - 1]                index2 = index2 - 1 #Here we move the item up by 1 space and decrement index2 by 1. Then we check again to see if the item is in the correct place. If still not in the correct place, we repeat the while loop, moving all the items before the one we are comparing up one place till we discover the correct location.        End While #drop out of the while loop.          items[index2] = current #take a copy of the item we are comparing held in current, place the copy in its correct location. #outer for loop now increments and the whole process repeats. This time we are trying to locate the correct position of the next item.  End for],
[Front: insertion sort pseudocode without comments Back: For index = 1 TO items.Length :       current = items[index]        index2 = index         While index2 > 0 AND items[index2 - 1] > current              items[index2] = items[index2 -1]              index2 = index2 - 1        End While           items[index2] = current End For],
[Front: Inefficienies of insertion sort Back: Having to move all the items in the data structure so we can insert the ""current"" item into its new location - only to find that we need to repeat the process again and again. Gets worse with larger data sets and if data is poorly sorted already when inserting.  Could have used a linked list which would negate the need to move items within the data structure. Instead we would need to update various pointers linking nodes together to reflect new structure  each iteration.],
[Front: Stacks Back: Items are pushed onto the top of the stack when added Popped off the top when deleting Peek  = look at top without deleting Last in First out Structure Last pushed on must be first popped off stack pointer always points to the node on the top any attempt to push an item onto a full stack is called a stack  overflow any attempt to pop an item of an empty stack is called stack  undeflow Often implemented using an array can also be created using OOP.],
[Front: Queue Back: Linear data structure Enqueued at the back Dequeued from the from can peek at the fron without deleting it priority queue -  certain items can join the front of the queue First in First out structure back/tail pointer always points to the last item in the queue front/head pointer - points to the first attempts to enqueue items to a full queue is queue overflow dequeue an empty queue is queue underflow Can be implemented using an array or OOP.],
[Front: Implementation of pushing onto a stack using a static array Back: 1. check the stack and output and error if its ful 2. increment the stack pointer insert the new data item at the location pointed to by the stack  pointer  function isFull(top)     if top == maxSize - 1 then           return true     else          return false     end if end function  procedure push(stack, top, data)          if isFull(top) == True then             print(""stack is full"")          else              top = top + 1              stack[top] = data           end if           return top end procedure],
[Front: Implementation of pushing onto a stack using OOP and a linked list Back: class Node        private data        private next         public proecdure new(newItem)           data  = newItem           next = Null        end procedure         public function getData()           return data        end procedure              public function getNext()           return next        end procedure         public procedure setNext(newNext)              next = newNext        endprocedure  public procedure push (data)          newNode = Node(data)           if top != Null then               newNode.setNext(top)           end if           top = newNode end proecedure  end class  class Stack        private top         public procedure new()                  top = Null        end procedure  end class],
[Front: Measurements of algorithm efficiency Back: Time complexity - how much time they need to solve a problem Space complexity - Amound of resources they require],
[Front: Comparing linear and binary search on a large data set. Back: Linear Binary                 Items do not need to be stored in order Items must be in order for the algorithm to work Start at the first item start at the middle item Search each item in sequence until each item is found or there are no items to  check halves the set of items to search after each comparison until the item is found or there are no more items to check - Divide and Conquer reduces data set by half each iteration. Can be implemented using an array or linked list Can be implemented using an array or binary tree new items are added at the end - quick New items must be added in the correct place to maintain the order of items - can be slow suitable for small number of items Suitable for a large number of items],
[Front: Merge Sort overview Back: Can sort a data set extremely quickly using divide and conquerPrinciple of divide and conquer is to create 2 or more identical subproblems from the larger problem, solve them individually and combine their solutions to solve the overaching problem.Divide the unsorted list into n sublists, each containing one element.Repeatedly merge sublists, to produce new sorted sublists until there is only sublist remaining, being the sortest list.]"
"Title: Merge Sort and Its Applications

Chapter Summary:
This chapter provides an in-depth understanding of merge sort, a well-known sorting algorithm. We explore its applications, suitability for different data sets, and its efficiency in terms of memory usage and runtime. Additionally, we delve into how merge sort can be effectively implemented in parallel processing environments through the concept of divide and conquer.

Chapter Content:
1. Introduction to Merge Sort
   1.1 Overview and importance
   1.2 Key characteristics

2. Algorithmic Steps
   2.1 Divide and conquer strategy
   2.2 Step-by-step breakdown of merge sort
      2.2.1 Dividing the list
      2.2.2 Merging adjacent lists
      2.2.3 The role of the merge function

3. Applications of Merge Sort
   3.1 Suitable data sets for merge sort
   3.2 Best practices for large data sets
   3.3 Minimizing sort time
   3.4 Benefits in parallel processing environments","[Front: Applications of merge sort Back: Suitable fot any data sets but works best with large ones where memory is not a concern However, the time take to perform the sort should be minimised. Ideal for parallel processing environments where the concept of divide and conquer can be used.],
[Front: Merge sort steps Back: Repeatedly divide the list in half until each item is in its own list Take 2 adjacent lists and start with the first item in each one Compare the 2 items Insert the lowest items into a new list. Move to the next item in the list it was taken from Repeat steps 3 and 4 until all the items from one of the lists are in the new list Append all the items from the list that still contains items to the new list Replace 2 adjacent lists with the new listRepeated from step 2 until all adjacent lists have been compared Repeat from step 2 until only one list remains Steps 3 to 6 take place inside the merge function]"
"Title: Merge Sort Pseudocode Implementation

Chapter Summary:
In this chapter, we walkthrough the pseudocode implementation of merge sort. By breaking down the merge sort algorithm into individual steps, we establish a clear understanding of how to code it. We begin with the process of dividing the list and eventually reach the efficient merging of adjacent lists through the merge function.

Chapter Content:
1. Overview of Merge Sort Pseudocode
   1.1 Importance of pseudocode in algorithm development
   1.2 Outline of merge sort pseudocode

2. Step 1: Dividing the List
   2.1 Repeatedly dividing the list
   2.2 Converting items into individual lists

3. Step 2: Merging Adjacent Lists
   3.1 Iterating until only one list remains
   3.2 Details of merging pairs of lists
   3.3 Role of the merge function

4. Merge Function Implementation
   4.1 Comparing items from two lists
   4.2 Inserting the lowest item into a new list
   4.3 Moving to the next item in the list
   4.4 Repetition until one list is fully merged","[Front: Merge sort psuedocode step 1: Repeatedly divide the list in half until each item is its own list. Back: #main algorithm starts here items = [""Florida"" ,""Georgia"",""Delaware"",""Alabama""] listOfItems = [] item = [] #every item is put into its own list with a containter list  for n = 0 TO items.length - 1       item = items[n]       listOfItems.append(item)  #listOfItems contains a set of lists that all contain a single item],
[Front: Merge sort psuedocode step 2: Take 2 adjacent lists and start with the first item in each one Back: #Repeat while there is more than one list While listOfItems.Length != 1           index = 0           #Merge pairs of lists           While index < listofItems.Length - 1               newList = merge(listOfItems[index], listOfItems[index+1])  #function to merge 2 lists into a new list Function merge(list1, list2)          newList = []          index1 = 0          index2 = 0]"
"Title: Detailed Merge Sort Pseudocode Steps

Chapter Summary:
This chapter provides a comprehensive breakdown of the pseudocode steps involved in merge sort. We explain in detail how to compare items, insert the lowest item into a new list, and continue the merging process until all items from one of the lists are in the new list. By understanding these steps, readers will gain a deeper insight into the inner workings of merge sort.

Chapter Content:
1. Comparing and Inserting Items
   1.1 Checking each item in both lists
   1.2 Adding the smallest item to a new list
   1.3 Moving to the next item in the respective lists

2. Handling List Discrepancies
   2.1 Considering different list lengths
   2.2 Handling equal elements in the lists

3. Repetition and Finalization
   3.1 Repeating the comparison and insertion process
   3.2 Concluding when all items from one list are merged
   3.3 The resulting ""newList"" and its significanc","[Front: Merge sort psuedocode step 3: Compare the 2 items and step 4: insert the lowest item into a new list, move from the next item in the list it was take from. Step 5: Repeat steps 3 and 4 until all the itmes from one of the lsits are in the new list. Back: #Check each item in each list, and add the smallest item to a new list  While index1 < list.Length and index2 < list2.Length          If list1[index1] > list2[index2] Then             newList.append( list2[index2])             index2 = index2 + 1          Else if list1[index1] < list2[index2] Then             newList.append(list1[index1])             index1 = index1 + 1           Else if list1[index1] == list2[index2] Then             newList.append( list2[index2])             index2 = index2 + 1             newList.append(list1[index1])             index1 = index1 + 1           End if End While #the process needs to be repeated until all the items from one of the lists have been put into the ""newList""]"
"Chapter Title: Merge Sort

Chapter Overview:
This chapter provides an in-depth understanding of the merge sort algorithm, which is a widely used sorting technique. Merge sort is known for its efficiency and ability to handle large data sets. The chapter covers the step-by-step process of merge sort, including merging two adjacent lists and repeating the process until only one list remains. It also presents a graphical representation of the merge sort process. Additionally, the chapter includes pseudocode and a main program of merge sort.

Topics Covered:
1. Introduction to merge sort
2. Step-by-step process of merge sort
3. Appending left-over items
4. Replacing adjacent lists
5. Repeating the process
6. Pseudocode for merge sort
7. Main program implementation","[Front: Merge sort step 6: Append all of the items from the list that still contains items to the newList Back: #add left over items from the remaining list If index1 < list.Length Then     For item = index1 to list1.Length            newList.append(list1[item])     Next item Else if index2 < list2.Length Then     For item = index2 to list2.Length           newList.append (list2[item)     Next Item End if Return newList  #main program newList = merge(listOfItems[index], listOfItems[index+1]],
[Front: merge sort Step 7: replace 2 adjacent lists with the new list step 8: repeat from step 2 until all adjacent lists have been compared. 9: Repeat from step 2 until only one list remains. Back: #repeat while there is more than one list While listOfItems.Length != 1        index = 0        #Merge pairs of lists        While index < 1 list of items.Length - 1                 newList = merge(listOfItems[index], listofItems[index+1])                 listofItems[index] = newList                 #once merged, delete one of the now redunant lists                 del listOfItems[index+1]                  index = index + 1         End while End while],
[Front: Linear search psuedocode from textbook Back: ],
[Front: Applications of insertion sort Back: Useful for small data sets Particularly useful for insterting items into a ready sorted list.],
[Front: Merge sort process graphically Back: ],
[Front: Merge sort textbook psuedocode Back: ]"
"Chapter Title: Quick Sort

Chapter Overview:
This chapter explores the quick sort algorithm, which is renowned for its fast sorting capabilities and efficiency in memory usage. Quick sort follows the divide and conquer approach and uses a pivot value for comparison with other items to determine their positions. The chapter details the steps involved in the quick sort process, including selecting the pivot value, dividing the list, and recursively invoking quick sort on sublists. It also discusses the advantages and disadvantages of quick sort and examines its various applications.

Topics Covered:
1. Introduction to quick sort
2. Overview of the quick sort algorithm
3. Selection of the pivot value
4. Partitioning the list
5. Recursive invocation of quick sort
6. Advantages and disadvantages of quick sort
7. Applications of quick sort","[Front: Quick sort overview Back: Orders a data set extremely quickly using divide and conquer Uses a pivot value from the data set which other items are compared against to determine their position. Typically requires less memory than merge sort.],
[Front: Applications of quick sort Back: Suitable for any data set but more for larger data sets. Ideal for parallel processing environments where divide and conquer can be used. Used in: Medical monitoringLife support systemsAircraft controlsDefence systems],
[Front: Quick sort steps Back: Select a value to be pivot value. Used to compare values. Final position of pivot value is called split point which is used to divide the list for subsequent calls. Select a leftmark and right mark, beginning and end of remaining items in list. If the leftmark is less than pivot value, move leftmark pointer to the right till you find a leftmark value greater than pivot.If the rightmark pointer is greater than pivot value, move rightmark pointer to left till you find a rightmark value less than pivot.Exchange leftmark and rightmark values.Continue with leftmark rightmark moving process.Once leftmark and right mark have crossed, stop moving process.Swap pivot value for the place stopped (split point).LHS of split point is less and RHS is greater, list can be divided at split point and quick sort invoked recursively on 2 halves.],
[Front: Quick sort psuedocode Back: ],
[Front: Advantages of quick sort Back: Extremely fast. If partition always occurs in middle of the list there will be log n divisions in a list of length n, and each of the n items need to be checked against pivot value to find split point. O(n log n). Doesn't need additional memory.],
[Front: Disadvantages of quick sort Back: If split points are not near the middle of the list, but close to start or end, division will be uneven. If split point is first item in a list, division results in a list of 0 items and a list of n-1 items. List of n-1 items divides into 0 items and n-2 items and so on. Resulting in time complexity O(n^2) If list is large and recursion takes too long, may cause stack overflow and program will crash.],
[Front: Djikstra's shortest path algorithm overview Back: Find's the shortest path between one start node and all other nodes on a weighted graph. A type of breadth first search.],
[Front: Disadvantage to Djikstra's shortest path algorithm Back: Doesn't work for edges with a negative weight value.]"
"Chapter Title: Dijkstra's Shortest Path Algorithm

Chapter Overview:
This chapter delves into Dijkstra's shortest path algorithm, a fundamental algorithm used to find the shortest path between a starting node and all other nodes on a weighted graph. The chapter explains the step-by-step process of Dijkstra's algorithm, including setting temporary distances, finding the node with the shortest distance, calculating distances from the start, updating distances, and marking nodes as visited. It also covers different implementations of Dijkstra's algorithm, such as using a table or array and utilizing queues and lists. The chapter concludes by discussing the applications and limitations of Dijkstra's algorithm.

Topics Covered:
1. Introduction to Dijkstra's shortest path algorithm
2. Step-by-step process of Dijkstra's algorithm
3. Setting temporary distances
4. Finding the node with the shortest distance
5. Calculating distances from the start
6. Updating distances and previous nodes
7. Marking nodes as visited
8. Implementations of Dijkstra's algorithm
9. Applications of Dijkstra's algorithm
10. Limitations of Dijkstra's algorithm
11. Worked example of Dijkstra's algorithm using a table
12. Dijkstra's algorithm implemented using a queu","[Front: Difference between Djikstra's and A* Back: A* uses heuristics while Djikstra's does not.],
[Front: Applications of Djikstra's Back: Used for purpose to find the shortest path between 2 points e.g.: GPS navigationIP routingTelephone networking],
[Front: Ways to implement Djikstra's Back: Using a table or array Queues and a series of lists],
[Front: Djikstra's shortest path steps Back: Set temporary distances from start value for all nodes. 0 for start node and infinity for others.For each node in the graph:Find the node with the shortest distance from the start that hasn't been visited.For each connected node that hasn't been visited:calculate distance from startIf the distance from the start is lower than the currently recorded distance from the start:Set the shortest distance to the start of the connected node to the newly calculated distance.Set previous node to be current nodeMark the node as visited.Start from goal node.Add previous node to start of the listRepeat from step 5 until start node reachedOutput list 1 - 3 calculates shortest path 4 - 7 outputs the shortest path from start node to goal node],
[Front: Worked example of Djikstra's using table Back: Find the node with shortest distance from start that hasn't been visited. Which is node A, has a distance of 0 from start node.  Now consider each connected node, not yet visited. B,C,D.  First consider B, calculate distance from start, so A's distance from start + the A to B edge weight: 0 +4 = 4.  Check if B's calculated distance from start is lower than current recorded distance from start: 4 < infinity so update B's distance from start to new distance and set previous node column to be the current node, A.  Now consider C and D. C: 0 +3 = 3. D: 0 + 2 = 2. Both < infinity so update C and D distnace and set previous node to A.  All A's connected nodes have been considered so A can be marked as visited.  Next consider the node with the shortest distance from start that hasn't been visited: D. Consider each node connected to D that hasn't been visited: C and F.  Calculate each nodes distance to start so D's distance from start + B to node's edge weight. C: 2 +1 = 3. This is not less than recorded distance from the start so no update required. F: 2+2 = 4. 4 < inifinity, so update F distance from start. All D connected nodes considered so marked as visited.   Next consider the node with the shortest distance from start that hasn't been visited: C. Consider each node connected to C that hasn't been visited yet. Both A and D have been visited already so, C can be marked as visited.  Next consider the node with the shortest distance from start that hasn't been visited: B or F. Consider B: Consider each node connected to B not visited yet: E. E distance from start: 4 + 4 = 8. 8 < infinity so update E distance from start. Update the previous node we've come from, B. B has had all of its connected nodes considered so mark as visited.  Node with shortest distance from start not yet visited: F. Consider each node connected to F not visited: G. G's distance from start : F's distance from start + F to G edge weight : 4 + 5 = 9. 9 < infinity so update G in table.  Done with F so it is marked as visited.   Node with shortest distance from start not visited: E. Each node connected to E not yet visited: G. G's distance from start: E's distance from start + E to G edge weight: 8 +2 = 10. 10 > 9 so not updated. Finished with E so mark it a visited.  Node with shortest distance from start not yet visited: G. Consider each node conncted to G not yet visited. None so G is marked as visited.  Outputting shortest path: Start with goal node and follow previous node back to start, inserting new node at front of the list. A to G: A → D → F → G.],
[Front: Djikstra's algorithm implemented using a queue Back: Assign a temporary distance value to each node, 0 for starting node and infinity for other nodesAdd all edges to a priority queue, sorted by current distance (putting starting node at the from, rest in random order)While queue is not empty:Remove the node ,u, from front of queueFor each unvisited neighbour, w, of the current node u:newDistance = distanceAtU + distanceFromUtoWif newDistance < distanceAtW thendistanceAtW = newDistancechange position of w in priority queue to reflect new distance to wendifnext wend while]"
"Chapter 1: Introduction to A* Pathfinding Algorithm
- Overview of the algorithm
- Basic concept of finding the shortest path between two nodes on a weighted graph
- Comparison to Dijkstra's algorithm
- Best-first search algorithm
- Importance of heuristics in A* pathfinding
- Definition and role of cost functions: g(x) and h(x)
- Calculation of total cost using f(x) = g(x) + h(x)

Chapter 2: A* Pathfinding Algorithm in Action
- Step-by-step explanation of the algorithm using a worked example
- Initialization of g and f values for all nodes
- Selection of the node with the lowest f value
- Calculation of distances from the start node to connected nodes
- Update of f value and previous node for each connected node
- Visiting nodes and repeating the process until the goal node is reached
- Outputting the shortest path

Chapter 3: Applications of A* Pathfinding Algorithm
- Usage in video games for NPC movement and intelligent pathfinding
- Network packet routing and optimization
- Financial modeling for trading assets and goods
- Solving puzzles, such as word ladders
- Social networking analysis for calculating degrees of separation

Chapter 4: Implementing A* Pathfinding Algorithm
- Different ways to implement the algorithm
- Single table/array approach for worked examples
- Usage of two lists or dictionaries for unvisited and visited nodes
- Introduction to priority queues
- Considerations for mixing different data types in the implementation

Chapter 5: Complexity Analysis and Big O Notation
- Introduction to measuring algorithm complexity
- Definition of time complexity and space complexity
- Overview of Big O notation and its purpose
- Categorization of common time complexities: O(1), O(log n), O(n), O(n^2), O(2^n)
- Explanation of each time complexity category with examples","[Front: A* pathfinding algorithm overview Back: Findes the shortest path between 2 nodes on a weighted graph using heuristics. Best first search algorithm, performs better than Djikstra's algorithm because not every node is considered, instead only most optimal path is followed to the goal. A heuristic estimates the cost of the path between the next node and the goal and follows the path. Has 2 cost function - g(x) real cost from source to a given node. h(x) - approx cost from node x to goal node, heuristic funciton, adequete solution not always optimum. Hueristic funciton should never overstimate the cost, real cost should always be > or = to h(x). total cost of each node is calcuated as f(x) = g(x) + h(x)]"
"Chapter 1: Overview of A* Pathfinding Algorithm Applications
- Introduction to the various applications of A* pathfinding
- Usage in video games for intelligent NPC movement
- Network packet routing and optimization in communication systems
- Financial modeling applications for trading assets and goods
- Solving puzzles, such as word ladders, efficiently
- Social networking analysis and suggesting friends based on degrees of separation

Chapter 2: Admissible Heuristics in A* Pathfinding
- Definition and importance of admissible heuristics
- Calculation of sensible heuristic estimates using additional data
- Examples of admissible heuristics in different scenarios: town distances, 2D maze
- Use of coordinates and distances to estimate heuristics
- Ensuring admissible heuristic estimates to maintain algorithm correctness

Chapter 3: Worked Example of A* Pathfinding Algorithm
- Step-by-step explanation of the algorithm using a detailed example
- Initial setup with g and f values for all nodes
- Consideration of connected nodes and calculation of distances from the start node
- Updating the table with lower f values and setting previous nodes
- Visiting nodes until the goal node is reached
- Outputting the shortest path discovered and potential optimality of routes

Chapter 4: Ways to Implement A* Pathfinding Algorithm
- Various approaches to implementing A* pathfinding
- Single table/array overview for simplicity in examples
- Introduction to using lists or dictionaries for unvisited and visited nodes
- Utilization of priority queues for efficient node selection
- Considerations for data types and their impact on implementation efficiency

Chapter 5: Complexity Analysis and Big O Notation in A* Pathfinding
- Evaluation of algorithm complexity in A* pathfinding
- Understanding time complexity and space complexity
- Introduction to Big O notation and its use in expressing algorithm scalability
- Explanation of worst-case scenario consideration
- Overview of common time complexity categories: O(1), O(log n), O(n), O(n^2), O(2^n)","[Front: Applications of A* pathfinding algorithm Back: Used in video games - moving NPCs appearing to move intelligentlyNetwork packet routingFinancial modelling for trading assets and goodsSolving puzzles like word laddersSocial networking analysis - calculating degrees of seperation between individuals to suggest friends],
[Front: Admissible Heuristics Back: Sensible heurstic estimates calculated from additional data. e.g. Nodes represent towns, edges represent distances in km, Longitude and Latitude of each node to calculate straight line distance from any node to destination -  gives an admissible heuristic estimate. e.g. Nodes in a 2D maze, using OOP, each node can have its own set of coordinates and horizontal + vertical distance between nodes ignoring obstables can be used as heuristics. Or could calculate Pthag to find euclidean distance.],
[Front: Worked example of A* pathfinding algorithm Back: Starting with node A, set g = 0 and f = 34. Other g's of other nodes have been set to infinity. Start with A, consider each connected node, not yet visited: C and D. Considering C: calcuate shortest distance from start (g): A's distance from start to A-C edge value: 0 + 10, then f value : 10 + 22 =32, 32 < infinity so update table and set previous node to A.  Consider other node, D: D's g value is A's distance from start + A-D edge weight: 0 +4 = 4, F value = 4 + 27 = 31 < infinity so update table and set previous node to A. All of A's connected node's have been considered so A has now been visited.  Now consider next unvisited node with lowest f value: D. D's connected nodes: E, E's g is = D's distance from start + D-E edge weight: 4+1 = 5, E f value: 5 + 24 = 29 < inifinity so update E in table and set previos node to D. Now all of D's connected nodes have been considered, so set it to visited.  Now consider next unvisited node with lowest f value: E. E's connected nodes not visited: C,G,H,J. Calculate g and f values and update table if f value is lower. C: g = 5+4 = 9 f = 9+22 = 31 f value is lower so update table. G: g = 5+4 = 9 f = 9+27 = 36 f value is lower so update table. H: g = 5+6 = 11 f = 11+13 = 24 f value is lower so update table. J: g = 5+7 = 12 f = 12+16 = 28 f value is lower so update table. All of E's connected nodes have been considered so it has now been visited.  Now consider next unvisited node with lowest f value: H. Consider each unvisited node connected to H: I,M. I: g = 11 + 9 = 20, f = 20 + 9 = 29. f value is lower so update table. M: g = 11+6 = 17, g = 17+5=22. f value is lower so update table. All of H's connected nodes have been considered so now it is visited. Now consider next unvisited node with lowest f value: M. Consider each unvisited node connected to M: L. L:  g = 17+4=21, f = 21+0=21 f value is lower so update table. All of M's connected node have been considered so update table.  A route to L has been found: A → D → E → H → M → L, possible more optimal route from I to L. We need to follow the algorithm through until the goal node has been visited. Now consider next unvisited node with lowest f value: L.  Consider each unvisted node connected to L: I. I: g = 21+5=26, f=26+29 =55, higher than the currently stored f value (29) so don't update table. L has now been visited so set it to visited. Now found the goal node, considered all adjacent nodes. Once goal node is visited, there are no shorter paths to discover.  A → D → E → H → M → L],
[Front: A* pathfinding algorithm in steps Back: Set initial g and f value for all nodes in the graph. (0 or start node and infinity for all other nodes)While goal not visited:Find the node with lowest f value not yet visitedFor each connected node that has not been visted:Caculate distance from start by adding edge value and heuristicIf distance from start + heuristic < than current f value:Set f value of connected node to the newly calculated distance.Set the previous node to be current node.Set current node as visited.Start from goal node.Add the previous node to the start of the list.Repeat from step 3 until start node is reached.Output list. Steps 1 and 2 calculates the shortest path. Steps 3-6 outputs the shortest path.],
[Front: Ways to implement A* pathfinding algorithm Back: For worked examples in real life, can use a single table / array. Implementing as an array, wouldn't be able to mix string and integer data types easily without lots of unnecessary casting. Could use 2 lists or dictionariesOne for containing all unvisited nodesOne for containing all visited nodesAdd each node to a priority queue when its first discovered, once it has left it is then classed as visited.],
[Front: Measures of an algorithm's complexity Back: Time complexitySpace complexity Algorithms should aim to run as quick as possible and take up the least amout of space possible.],
[Front: Big O notation Back: Used to express the scalability of an algorithm as its order. Expresses the time complexity, or performace of an algorithm. Considers worst case scenario, assumes that every possible element is touched on as the algorithm executes.],
[Front: Big O notation categories Back: O(1) - Constant timeO(log n) Logarithmic timeO(n) - Linear timeO(n^2) - Polynomial timeO(2^n) - Exponential time],
[Front: O(1) - Constant time Back: An algorithm that takes the same amount of them to execute regardless of the size of the input data set.  e.g. len(list) will take the same amount of them to execute no matter the number of items in the list.],
[Front: O(log n) Logarithmic time Back: An algorithm's time take to complete will grow very slowly as data set size increases.  e.g. Binary search is log base 2 n, doubling size of data set has very little effect on the time the algorithm takes to complete.]"
"Chapter 1: Linear Time Complexity Algorithms
- Definition and characteristics of algorithms with O(n) complexity
- Performance proportional to the data set size
- Declining efficiency with larger data sets
- Example of linear search algorithm

Chapter 2: Polynomial Time Complexity Algorithms
- Introduction to algorithms with O(n^2) complexity
- Performance proportional to the square of the data set size
- Significant reduction in efficiency with larger data sets
- Explanation of nested loops and their impact on complexity

Chapter 3: Analyzing Algorithm Complexity
- Importance of analyzing and understanding complexity
- Overview of measuring time and space complexity
- Challenges of scaling algorithms
- Introduction to Big O notation as a tool for expressing complexity
- Categorization of common complexities: O(1), O(log n), O(n), O(n^2), O(2^n)

Chapter 4: Practical Considerations for Algorithm Efficiency
- Strategies for optimizing algorithm performance
- Importance of selecting appropriate data structures
- Techniques for reducing time and space complexity
- Trade-offs between efficiency and other factors
- Continuous improvement and analysis of algorithmic efficienc","[Front: O(n) - Linear time Back: An algorithm with the time to complete it grows in direct proportion to the data set size.  Performance declines as data set grows. Reduces efficiency with increasingly large data sets. e.g. Linear search list of 1000 items will take 1000 times longer than searching a list of 1 item.],
[Front: O(n^2) - Polynomial time Back: An algorithm where performance is directly proportional to the square of the data set size.  Significantly reduces efficiency with increasingly large data sets.  e.g. nested loops, e.g. of 3 nests = n^3, 4 nests = n^4.]"
