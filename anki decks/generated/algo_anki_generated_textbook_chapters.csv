"Chapter 1: Linear Search
1.1 Overview of Linear Search
- Definition of linear search
- Process of finding an item in a (un)sorted list
- Efficiency for smaller and larger data sets

1.2 Applications of Linear Search
- Finding items in small data sets
- Searching unordered data (e.g., settings file)
- Find and replace function in a word processor

1.3 Pseudocode for Linear Search
- Detailed explanation of the pseudocode with comments
- Initialization of variables and loop conditions
- Sequential checking of items in the data set

1.4 Limitations of Coded Linear Search
- Exiting as soon as the first occurrence is found
- Consideration for finding first, last, or all occurrences

Chapter 2: Binary Search
2.1 Overview of Binary Search
- Efficiency of binary search compared to linear search
- Requirement of a sorted data set
- Division of the list in half to locate the item

2.2 Applications of Binary Search
- Searching for items in a large sorted data set
- Example: Online dictionary with words in alphabetical order
- Reduction of large data sets to a more manageable size

2.3 Pseudocode for Binary Search
- Explanation of the pseudocode with comments
- Usage of variables for tracking the first and last positions
- Calculation of the midpoint for comparison","[Front: Linear Search overview Back: Finds an item in a(n) (un)sorted list. Starts at the first item and checks each item one by one. Doesn't required the data set to be in order Can be efficient for smaller data sets Inefficient for large data sets],
[Front: Applications of linear search Back: Ideal for finding items in small data sets and searching unoredered data such as a settings file. Typical use of linear search would be a find and replace function in a word processor Easiest search algorithm to implement but usually most inefficient.],
[Front: Linear search psuedocode Back: found  = False index = 0  # start by initialising variables with their starting state. # ""found"" Boolean value is used to indicate whether the item we are searching fro has been found or not - start with False. # ""index"" specifies current position in the data set, starting at 0, we will assume the data being searched is stored in array or list. While found == False and index < items.Length #We enter a While loop that will continue to execute while found is False and index is less than the lengh of the items list.            If items[index] == itemToFind then #Each time around the loop, the program checks to see if the current item is the one we are searching for.                found = True #if it is, then Found is set to true causing the exit of the loop at the start of next iteration            Else                index = index + 1 #if it isn't then increment index by 1, meaning next iteration of the loop, the program will be checking against the next location the data set.            End IF  End While],
[Front: Linear search psuedocode without comments Back: found = False index = 0   While found == False and index < items.Length            If items[index] ==  itemToFind then                found = True            Else                index = index + 1            End If End While],
[Front: Linear search algorithm must: Back: Be able to locate an item in a data set if it exists Be able to locate the item regardless of whether the data set is sorted or not. Run without crashing even if the item being searched for doesn't eexist in the data set. Check each item sequentially starting with the first item.],
[Front: Limitations of coded linear search: Back: Version exits as soon as the first occurence of the item is found What if you wanted to find the first, last or all occurences?],
[Front: Binary search overview Back: Efficient algorithm for finding an item in a sorted data set. More efficient than linear search. Starts at the middle of the list and repeatedly divides the list in half Requires the data set to be sorted first e.g. numerical or alphabetical order Efficient for large data sets],
[Front: Applications of binary search Back: Ideal when you need to search for an item in a large sorted data set e.g.  online dictionary where words are sorted in alphabetical orderAs it discards half of the data after each iteration, it quickly reduces the very large data sets containing millions of records to one much more manageable.],
[Front: Psuedocode binary search Back: found = False first  =  0 last = items.length - 1 #found is used to indicate whether the item we are searching for has been found or not- seting it to false #first/last: with each iteration, we need to know the curretn index of the first and last item in data set so we can find the mid point. MP changes with each iteration. To start with, we will be searching the entire data set, so set ""first"" to index 0 and ""last"" to length of data set - 1 which will be the index of the last item.  While first <= last and found == False #Enter a while loop that continue to iterate providing both first <= last and found == False. Loop will iterate until item is found or entire data set has been searched.       midpoint = (first + last) DIV 2 #Calculate the MP of data set. Add index values in ""first"" and ""last"" and do floor division to get an integer.       IF items[midpoint] == itemToFind then #Each iteration, program checks if the item at the MP of the data set is the one we are searching for.           found = True #if it is, ""found"" is set to True and loop will exit at the start of the nnext iteration       Else           If items[midpoint] < itemToFind then #if not then program will check if the MP is less than or greater than the desired item, allowing us to discard half the entire data set. We can do this becuase items in the data set of a binary search are stored in order.              first = midpoint + 1 #if item at MP is less than the desired value, we adjust ""first"" to point at the index value in MP + 1           Else               last = midpoint = 1 #if item at MP is more than the desired value, we adjust ""last"" to point at the index value in MP - 1 #Repeat while loop until we find desired item or prove that item is not in data set.           End If        End If End While]"
"Chapter 3: Bubble Sort
3.1 Overview of Bubble Sort
- Definition and purpose of bubble sort
- Comparison-based sorting algorithm
- Swapping adjacent items to move the largest/smallest to the end

3.2 Applications of Bubble Sort
- Ideal for very small data sets
- Situations where simplicity and easy implementation are required

3.3 Pseudocode for Bubble Sort
- Explanation of the pseudocode with comments
- Usage of variables for tracking the progress and swaps
- Iteration through the data set and swapping of items","[Front: Binary seach psuedocode without comments Back: found = False first = 0 last = items.Length -1  WHILE first <= last and found == False         midpoint = (first+last) DIV 2         IF items[midpoint] == itemToFind then             Found = True         Else           IF items[midpoint] < itemToFind then               first = midpoint + 1           Else                last = midpoint - 1           End IF         End If End While],
[Front: Bubble sort overview: Back: Sorts an unordered list of items by comparing each item with the  next one and swapping the items if it is greater than it. Algorithm is finished when no more swaps can be made. It bubbles the largest or smallest up to the end of the list. Last element will be in correct place after first pass.]"
"Chapter 4: Review of Linear Search
4.1 Recap of Linear Search Overview
- Brief summary of linear search algorithm
- Strengths and weaknesses in terms of efficiency

Chapter 5: Review of Binary Search
5.1 Recap of Binary Search Overview
- Summary of binary search algorithm and its efficiency
- Necessity for a sorted data set

Chapter 6: Review of Bubble Sort
6.1 Recap of Bubble Sort Overview
- Summary of bubble sort algorithm
- Efficiency considerations and suitability for small data sets

*Note: Each chapter can be expanded with additional content, examples, exercises, and explanations to provide a comprehensive coverage of the topics","[Front: Applications of bubble sort Back: Most inefficient sorting algorithm Easy to implement Popular choice for very small data sets Ideal for situations where a simple easy to program sorting  algorithm is required.],
[Front: Bubble sort psuedocode Back: n = items.length swapped  = True # ""n"" used to track how far through the data set we need to check for items to swap on each iteration. start by setting it to then length of the data set.  #""swapped"" used to indicate whether a swap has taken place each iteration of the inner for loop. start by setting it to true so we will enter the main WHILE loop at least once to check for unsorted items. WHILE n > 0 AND swapped == True #enter a while loop which will iterate while n>0 and swapped == True. Loop will iterate until all items are sorted           swapped = False #each iteration the while loop assumes there are no items that need to be swapped until we prove otherwisw, so we set ""swapped"" to false.           n = n -1 #ensures that the length of the list is inline with 0 indexing. Ensures that the entire data set will be checked the first iterations for items to swap. This value will decrement by 1 each iteration of the outer WHILE loop. Sorted items will gradually, bubble up to the end of the data set so there will be fewer items to check through each iteration.           For index = 0 To n-1 #nested inner for loop. for each pass through the data set, respresented by the while loop, we need to start through the beginning and work through to the penultimate item of the unsorted data set, represented by n - 1. Need to work through the current subset of items that still need to be check.                If items[index] > items[index+1] then #if we find that the item at the current location in the data set is greater than the next item, we know it is out of order                    Swap(items[index] , items [index+1])                    swapped = True #we then swap the 2 items, then set ""swapped"" to true so that when we next check the outer while loop, we know we are still in the process of sorting the data out.                  End IF            End For #continue through the data set moving the item up as far as it needs to go until it is in the correct place. End WHILE #process is repeated as many times necessary until we discover the entire data set has been sorted.],
[Front: bubble sort pseudocode without comments Back: n = items.Length swapped = True  While n > 0 AND swapped == True           swapped = False           n = n -1           For index = 0 TO n-1                  If items[index] > items[index+1] then                     Swap(items[index] , items[index+1])                     swapped = True                 End if           End For End While]"
"Chapter Title: Insertion Sort

Introduction:
In this chapter, we will explore the Insertion Sort algorithm, which is used to sort data sets by inserting each item into its correct position. This algorithm is particularly useful for small data sets and for inserting items into a previously sorted list. However, it can become inefficient for larger data sets.

Overview:
Insertion sort works by iterating through the data set and comparing each item with the items before it. If an item is found to be in the wrong position, it is moved up in the data set until it reaches its correct position. This process is repeated for each item in the data set until the entire set is sorted.

Pseudocode with Comments:
The following pseudocode provides a step-by-step explanation of the Insertion Sort algorithm:

```
For index = 1 TO items.Length:
    current = items[index]
    index2 = index
    While index2 > 0 AND items[index2-1] > current:
        items[index2] = items[index2 - 1]
        index2 = index2 - 1
    End While
    items[index2] = current
End For
```

Pseudocode without Comments:
Here is the simplified pseudocode for Insertion Sort:

```
For index = 1 TO items.Length:
    current = items[index]
    index2 = index
    While index2 > 0 AND items[index2-1] > current:
        items[index2] = items[index2 - 1]
        index2 = index2 - 1
    End While
    items[index2] = current
End For
```

Inefficiencies of Insertion Sort:
Despite its simplicity, Insertion Sort has some inefficiencies. One major disadvantage is having to move all the items in the data structure to insert the current item into its new location. This process can be time-consuming, especially when the data set is already poorly sorted. Additionally, as the data set size increases, the inefficiency of Insertion Sort becomes more noticeable. One possible improvement is using a linked list instead of an array, which would eliminate the need to physically move items within the data structure.","[Front: Insertion sort overview: Back: Inserts each item into its correct position in a data set one at a  time. Useful for small data sets. Partically useful for inserting items into a ready sorted list Inefficient for larger data sets.],
[Front: Insertion sort psuedocode Back: For index = 1 TO items.Length: #algorithm sets a for loop to iterate through the data set #it compares the item in items[1] with item immediately before it, at items[0]. This is why the for loop starts at 1 not 0, if we started at 0, we would be trying to compare the very first item in the data set with one at position items [-1] which would cause an out of bounds error.        current = items[index] #first thing we do each iteration is take a copy of item we are sorting and place it in temporary ""current"". We do this because if we  find items before it are wrong order, we will need to move them  up in the data set. In doing this we would override the original  term and we need a way of getting back to insert it into its current location.        index2 = index #set index2 to be same value as index 1. index2 used to track where we need to exit inner While loop. Every iteration of outer FOR loop, we need to check the current item against items before it. As we iterate through the data set, this number increases.          While index2 > 0 AND items[index2-1] > current #inner while loop is executed if any additional items before the one one we are comparing that still needs to be checked with index2 > 0 AND we check if that the item is greater than the one we are comparing, if it is, then we know the items are out of place.                items[index2] = items[index2 - 1]                index2 = index2 - 1 #Here we move the item up by 1 space and decrement index2 by 1. Then we check again to see if the item is in the correct place. If still not in the correct place, we repeat the while loop, moving all the items before the one we are comparing up one place till we discover the correct location.        End While #drop out of the while loop.          items[index2] = current #take a copy of the item we are comparing held in current, place the copy in its correct location. #outer for loop now increments and the whole process repeats. This time we are trying to locate the correct position of the next item.  End for],
[Front: insertion sort pseudocode without comments Back: For index = 1 TO items.Length :       current = items[index]        index2 = index         While index2 > 0 AND items[index2 - 1] > current              items[index2] = items[index2 -1]              index2 = index2 - 1        End While           items[index2] = current End For],
[Front: Inefficienies of insertion sort Back: Having to move all the items in the data structure so we can insert the ""current"" item into its new location - only to find that we need to repeat the process again and again. Gets worse with larger data sets and if data is poorly sorted already when inserting.  Could have used a linked list which would negate the need to move items within the data structure. Instead we would need to update various pointers linking nodes together to reflect new structure  each iteration.]"
"Chapter Title: Stacks and Queues

Stacks:
A stack is a last-in, first-out (LIFO) data structure where items are added to the top and removed from the top. It follows the principle of Last in First out (LIFO), meaning the last item pushed onto the stack will be the first item popped off. Stacks can be implemented using an array or through object-oriented programming (OOP). Common operations on stacks include pushing (adding) an item onto the stack, popping (removing) an item from the stack, and peeking (looking at) the top item without removing it.

Queue:
A queue is a linear data structure that follows the first-in, first-out (FIFO) principle. In a queue, items are enqueued (added) at the back and dequeued (removed) from the front. It is often implemented using an array or OOP. Additionally, a priority queue allows certain items to join the front of the queue based on their priority level. Similar to stacks, the operations on a queue include enqueueing, dequeueing, and peeking at the front item without removing it.

Implementation of Pushing Onto a Stack:
There are different ways to implement pushing items onto a stack. One approach is using a static array, and the following steps outline this implementation:

1. Check if the stack is full.
2. Increment the stack pointer.
3. Insert the new data item at the location pointed to by the stack pointer.
4. Return the updated stack pointer.

Implementation of Pushing Onto a Stack using OOP and a Linked List:
Another implementation of pushing items onto a stack involves object-oriented programming (OOP) and a linked list. Here is an example implementation using classes:

```
class Node:
    private data
    private next
    
    public procedure new(newItem):
        data = newItem
        next = Null
    end procedure
    
    public function getData():
        return data
    end function
    
    public function getNext():
        return next
    end function
    
    public procedure setNext(newNext):
        next = newNext
    end procedure

public procedure push(data):
    newNode = Node(data)
    if top != Null:
        newNode.setNext(top)
    end if
    top = newNode
end procedure

class Stack:
    private top
    
    public procedure new():
        top = Null
    end procedure
end class
```","[Front: Stacks Back: Items are pushed onto the top of the stack when added Popped off the top when deleting Peek  = look at top without deleting Last in First out Structure Last pushed on must be first popped off stack pointer always points to the node on the top any attempt to push an item onto a full stack is called a stack  overflow any attempt to pop an item of an empty stack is called stack  undeflow Often implemented using an array can also be created using OOP.],
[Front: Queue Back: Linear data structure Enqueued at the back Dequeued from the from can peek at the fron without deleting it priority queue -  certain items can join the front of the queue First in First out structure back/tail pointer always points to the last item in the queue front/head pointer - points to the first attempts to enqueue items to a full queue is queue overflow dequeue an empty queue is queue underflow Can be implemented using an array or OOP.],
[Front: Implementation of pushing onto a stack using a static array Back: 1. check the stack and output and error if its ful 2. increment the stack pointer insert the new data item at the location pointed to by the stack  pointer  function isFull(top)     if top == maxSize - 1 then           return true     else          return false     end if end function  procedure push(stack, top, data)          if isFull(top) == True then             print(""stack is full"")          else              top = top + 1              stack[top] = data           end if           return top end procedure],
[Front: Implementation of pushing onto a stack using OOP and a linked list Back: class Node        private data        private next         public proecdure new(newItem)           data  = newItem           next = Null        end procedure         public function getData()           return data        end procedure              public function getNext()           return next        end procedure         public procedure setNext(newNext)              next = newNext        endprocedure  public procedure push (data)          newNode = Node(data)           if top != Null then               newNode.setNext(top)           end if           top = newNode end proecedure  end class  class Stack        private top         public procedure new()                  top = Null        end procedure  end class]"
"Chapter Title: Algorithm Efficiency

Measurements of Algorithm Efficiency:
When analyzing algorithms, two key measurements are considered: time complexity and space complexity. Time complexity refers to the amount of time an algorithm needs to solve a problem, usually denoted using Big O notation. On the other hand, space complexity refers to the amount of resources, such as memory or storage, that an algorithm requires. Both measurements help evaluate the efficiency of algorithms and compare different algorithms' performance.

Comparing Linear and Binary Search on a Large Data Set:
Linear search and binary search are two common searching algorithms used on data sets. The comparison between these algorithms on large data sets can be summarized as follows:

Linear Search:
- Items do not need to be stored in order.
- Starts at the first item and searches each item in sequence until the target item is found or there are no items left to check.
- Suitable for small numbers of items.
- Can be implemented using an array or a linked list.
- New items are added at the end, making it quick for insertion.

Binary Search:
- Items must be stored in order for the algorithm to work.
- Starts at the middle item and halves the set of items to search after each comparison until the target item is found or there are no more items to check (divide and conquer approach).
- Suitable for a large number of items.
- Can be implemented using an array or a binary tree.
- New items must be added in the correct place to maintain the order, which can be slow.

Merge Sort Overview:
Merge Sort is a divide and conquer sorting algorithm known for its efficiency in sorting large data sets. The algorithm follows the principle of divide and conquer by creating identical subproblems from the larger problem, solving them individually, and combining their solutions to solve the overall problem. Merge Sort works by repeatedly dividing the unsorted list into smaller sublists, sorting them, and then merging them back together until a single sorted list remains.

Applications of Merge Sort:
Merge Sort is suitable for any data set but works best with large data sets where memory is not a concern. This algorithm's main advantage lies in its ability to minimize the time taken to perform the sort. Merge Sort is often used in parallel processing environments, taking advantage of the divide and conquer concept to efficiently utilize multiple processors.

Merge Sort Steps:
The following steps outline the process of Merge Sort:

1. Repeatedly divide the list in half until each item is in its own list.
2. Take two adjacent lists and start with the first item in each.
3. Compare the two items, insert the lowest item into a new list, and move to the next item in the list it was taken from.
4. Repeat steps 3 and 4 until all the items from one of the lists are in the new list.
5. Append all the remaining items from the list that still contains items to the new list.
6. Replace the two adjacent lists with the new list.
7. Repeat from step 2 until all adjacent lists have been compared.
8. Repeat from step 2 until only one list remains.
9. Steps 3 to 6 take place inside the merge function.

Merge Sort Pseudocode - Step 1:
The initial step in Merge Sort involves dividing the list into smaller sublists, each containing one element. Here is the pseudocode for step 1:

```
# Main algorithm starts here
items = [""Florida"", ""Georgia"", ""Delaware"", ""Alabama""]
listOfItems = []
item = []

# Put each item into its own list with a container list
for n = 0 TO items.length - 1:
    item = items[n]
    listOfItems.append(item)","[Front: Measurements of algorithm efficiency Back: Time complexity - how much time they need to solve a problem Space complexity - Amound of resources they require],
[Front: Comparing linear and binary search on a large data set. Back: Linear Binary                 Items do not need to be stored in order Items must be in order for the algorithm to work Start at the first item start at the middle item Search each item in sequence until each item is found or there are no items to  check halves the set of items to search after each comparison until the item is found or there are no more items to check - Divide and Conquer reduces data set by half each iteration. Can be implemented using an array or linked list Can be implemented using an array or binary tree new items are added at the end - quick New items must be added in the correct place to maintain the order of items - can be slow suitable for small number of items Suitable for a large number of items],
[Front: Merge Sort overview Back: Can sort a data set extremely quickly using divide and conquerPrinciple of divide and conquer is to create 2 or more identical subproblems from the larger problem, solve them individually and combine their solutions to solve the overaching problem.Divide the unsorted list into n sublists, each containing one element.Repeatedly merge sublists, to produce new sorted sublists until there is only sublist remaining, being the sortest list.],
[Front: Applications of merge sort Back: Suitable fot any data sets but works best with large ones where memory is not a concern However, the time take to perform the sort should be minimised. Ideal for parallel processing environments where the concept of divide and conquer can be used.],
[Front: Merge sort steps Back: Repeatedly divide the list in half until each item is in its own list Take 2 adjacent lists and start with the first item in each one Compare the 2 items Insert the lowest items into a new list. Move to the next item in the list it was taken from Repeat steps 3 and 4 until all the items from one of the lists are in the new list Append all the items from the list that still contains items to the new list Replace 2 adjacent lists with the new listRepeated from step 2 until all adjacent lists have been compared Repeat from step 2 until only one list remains Steps 3 to 6 take place inside the merge function],
[Front: Merge sort psuedocode step 1: Repeatedly divide the list in half until each item is its own list. Back: #main algorithm starts here items = [""Florida"" ,""Georgia"",""Delaware"",""Alabama""] listOfItems = [] item = [] #every item is put into its own list with a containter list  for n = 0 TO items.length - 1       item = items[n]       listOfItems.append(item)  #listOfItems contains a set of lists that all contain a single item],
[Front: Merge sort psuedocode step 2: Take 2 adjacent lists and start with the first item in each one Back: #Repeat while there is more than one list While listOfItems.Length != 1           index = 0           #Merge pairs of lists           While index < listofItems.Length - 1               newList = merge(listOfItems[index], listOfItems[index+1])  #function to merge 2 lists into a new list Function merge(list1, list2)          newList = []          index1 = 0          index2 = 0],
[Front: Merge sort psuedocode step 3: Compare the 2 items and step 4: insert the lowest item into a new list, move from the next item in the list it was take from. Step 5: Repeat steps 3 and 4 until all the itmes from one of the lsits are in the new list. Back: #Check each item in each list, and add the smallest item to a new list  While index1 < list.Length and index2 < list2.Length          If list1[index1] > list2[index2] Then             newList.append( list2[index2])             index2 = index2 + 1          Else if list1[index1] < list2[index2] Then             newList.append(list1[index1])             index1 = index1 + 1           Else if list1[index1] == list2[index2] Then             newList.append( list2[index2])             index2 = index2 + 1             newList.append(list1[index1])             index1 = index1 + 1           End if End While #the process needs to be repeated until all the items from one of the lists have been put into the ""newList""],
[Front: Merge sort step 6: Append all of the items from the list that still contains items to the newList Back: #add left over items from the remaining list If index1 < list.Length Then     For item = index1 to list1.Length            newList.append(list1[item])     Next item Else if index2 < list2.Length Then     For item = index2 to list2.Length           newList.append (list2[item)     Next Item End if Return newList  #main program newList = merge(listOfItems[index], listOfItems[index+1]]"
"Chapter 1: Merge Sort
- Merge sort is a popular sorting algorithm that utilizes the divide and conquer approach.
- The algorithm consists of several steps, including replacing adjacent lists, repeating comparisons until one list remains, and merging pairs of lists.
- The pseudocode for merge sort is outlined in the textbook.
- It is particularly useful for sorting small data sets and inserting items into a pre-sorted list.
- The process of merge sort can be understood through a graphical representation.

Chapter 2: Quick Sort
- Quick sort is another efficient sorting algorithm that also employs the divide and conquer technique.
- The algorithm selects a pivot value and compares other items against it to determine their position.
- Quick sort requires less memory compared to merge sort and is suitable for larger data sets.
- It finds its applications in various domains such as medical monitoring, life support systems, etc.
- The steps of quick sort involve selecting a pivot value, choosing left and right marks, exchanging values, and invoking quick sort recursively.","[Front: merge sort Step 7: replace 2 adjacent lists with the new list step 8: repeat from step 2 until all adjacent lists have been compared. 9: Repeat from step 2 until only one list remains. Back: #repeat while there is more than one list While listOfItems.Length != 1        index = 0        #Merge pairs of lists        While index < 1 list of items.Length - 1                 newList = merge(listOfItems[index], listofItems[index+1])                 listofItems[index] = newList                 #once merged, delete one of the now redunant lists                 del listOfItems[index+1]                  index = index + 1         End while End while],
[Front: Linear search psuedocode from textbook Back: ],
[Front: Applications of insertion sort Back: Useful for small data sets Particularly useful for insterting items into a ready sorted list.],
[Front: Merge sort process graphically Back: ],
[Front: Merge sort textbook psuedocode Back: ],
[Front: Quick sort overview Back: Orders a data set extremely quickly using divide and conquer Uses a pivot value from the data set which other items are compared against to determine their position. Typically requires less memory than merge sort.],
[Front: Applications of quick sort Back: Suitable for any data set but more for larger data sets. Ideal for parallel processing environments where divide and conquer can be used. Used in: Medical monitoringLife support systemsAircraft controlsDefence systems],
[Front: Quick sort steps Back: Select a value to be pivot value. Used to compare values. Final position of pivot value is called split point which is used to divide the list for subsequent calls. Select a leftmark and right mark, beginning and end of remaining items in list. If the leftmark is less than pivot value, move leftmark pointer to the right till you find a leftmark value greater than pivot.If the rightmark pointer is greater than pivot value, move rightmark pointer to left till you find a rightmark value less than pivot.Exchange leftmark and rightmark values.Continue with leftmark rightmark moving process.Once leftmark and right mark have crossed, stop moving process.Swap pivot value for the place stopped (split point).LHS of split point is less and RHS is greater, list can be divided at split point and quick sort invoked recursively on 2 halves.],
[Front: Quick sort psuedocode Back: ]"
"Chapter 3: Advantages and Disadvantages of Quick Sort
- Quick sort offers several advantages, such as its speed and efficiency in sorting data sets.
- When the partition occurs near the middle of the list, the algorithm performs with a time complexity of O(n log n).
- Furthermore, quick sort does not require additional memory.
- However, quick sort also has its limitations, such as uneven division when the split points are near the start or end of the list.
- In such scenarios, the time complexity can degrade to O(n^2).
- Additionally, if the recursion takes too long, it may cause a stack overflow, leading to program crashes.

Chapter 4: Dijkstra's Shortest Path Algorithm
- Dijkstra's algorithm is used to find the shortest path between a start node and all other nodes in a weighted graph.
- It can be seen as a type of breadth-first search that takes into account the edge weights.
- The algorithm calculates temporary distances from the start node and iterates through connected nodes to update their distances.
- Dijkstra's algorithm has various applications, including GPS navigation, IP routing, and telephone networking.
- However, it cannot handle edges with negative weight values.","[Front: Advantages of quick sort Back: Extremely fast. If partition always occurs in middle of the list there will be log n divisions in a list of length n, and each of the n items need to be checked against pivot value to find split point. O(n log n). Doesn't need additional memory.],
[Front: Disadvantages of quick sort Back: If split points are not near the middle of the list, but close to start or end, division will be uneven. If split point is first item in a list, division results in a list of 0 items and a list of n-1 items. List of n-1 items divides into 0 items and n-2 items and so on. Resulting in time complexity O(n^2) If list is large and recursion takes too long, may cause stack overflow and program will crash.],
[Front: Djikstra's shortest path algorithm overview Back: Find's the shortest path between one start node and all other nodes on a weighted graph. A type of breadth first search.],
[Front: Disadvantage to Djikstra's shortest path algorithm Back: Doesn't work for edges with a negative weight value.]"
"Chapter 5: Differences between Dijkstra's and A*
- A* is a pathfinding algorithm that employs heuristics to guide its search, while Dijkstra's algorithm does not use any heuristics.
- The inclusion of heuristics allows A* to make informed decisions and often yield more optimal results.
- Dijkstra's algorithm, on the other hand, focuses solely on finding the shortest path based on edge weights.

Chapter 6: Implementations of Dijkstra's Algorithm
- There are various ways to implement Dijkstra's algorithm, including using a table or array, as well as queues and lists.
- The algorithm sets temporary distances from the start node for all nodes and iteratively updates these distances.
- It keeps track of the previously visited nodes and continues until the start node is reached.
- The resulting output is a list that calculates the shortest path and outputs the path from the start node to the goal node.

Chapter 7: Worked Example of Dijkstra's Algorithm
- To illustrate Dijkstra's algorithm, a step-by-step example is presented using a table.
- The example demonstrates how the algorithm iterates through nodes, calculates distances, updates the table, and marks visited nodes.
- By following this example, the process of finding the shortest path using Dijkstra's algorithm becomes clear.

Please let me know if you need any further clarification or have any additional requirements","[Front: Difference between Djikstra's and A* Back: A* uses heuristics while Djikstra's does not.],
[Front: Applications of Djikstra's Back: Used for purpose to find the shortest path between 2 points e.g.: GPS navigationIP routingTelephone networking],
[Front: Ways to implement Djikstra's Back: Using a table or array Queues and a series of lists],
[Front: Djikstra's shortest path steps Back: Set temporary distances from start value for all nodes. 0 for start node and infinity for others.For each node in the graph:Find the node with the shortest distance from the start that hasn't been visited.For each connected node that hasn't been visited:calculate distance from startIf the distance from the start is lower than the currently recorded distance from the start:Set the shortest distance to the start of the connected node to the newly calculated distance.Set previous node to be current nodeMark the node as visited.Start from goal node.Add previous node to start of the listRepeat from step 5 until start node reachedOutput list 1 - 3 calculates shortest path 4 - 7 outputs the shortest path from start node to goal node],
[Front: Worked example of Djikstra's using table Back: Find the node with shortest distance from start that hasn't been visited. Which is node A, has a distance of 0 from start node.  Now consider each connected node, not yet visited. B,C,D.  First consider B, calculate distance from start, so A's distance from start + the A to B edge weight: 0 +4 = 4.  Check if B's calculated distance from start is lower than current recorded distance from start: 4 < infinity so update B's distance from start to new distance and set previous node column to be the current node, A.  Now consider C and D. C: 0 +3 = 3. D: 0 + 2 = 2. Both < infinity so update C and D distnace and set previous node to A.  All A's connected nodes have been considered so A can be marked as visited.  Next consider the node with the shortest distance from start that hasn't been visited: D. Consider each node connected to D that hasn't been visited: C and F.  Calculate each nodes distance to start so D's distance from start + B to node's edge weight. C: 2 +1 = 3. This is not less than recorded distance from the start so no update required. F: 2+2 = 4. 4 < inifinity, so update F distance from start. All D connected nodes considered so marked as visited.   Next consider the node with the shortest distance from start that hasn't been visited: C. Consider each node connected to C that hasn't been visited yet. Both A and D have been visited already so, C can be marked as visited.  Next consider the node with the shortest distance from start that hasn't been visited: B or F. Consider B: Consider each node connected to B not visited yet: E. E distance from start: 4 + 4 = 8. 8 < infinity so update E distance from start. Update the previous node we've come from, B. B has had all of its connected nodes considered so mark as visited.  Node with shortest distance from start not yet visited: F. Consider each node connected to F not visited: G. G's distance from start : F's distance from start + F to G edge weight : 4 + 5 = 9. 9 < infinity so update G in table.  Done with F so it is marked as visited.   Node with shortest distance from start not visited: E. Each node connected to E not yet visited: G. G's distance from start: E's distance from start + E to G edge weight: 8 +2 = 10. 10 > 9 so not updated. Finished with E so mark it a visited.  Node with shortest distance from start not yet visited: G. Consider each node conncted to G not yet visited. None so G is marked as visited.  Outputting shortest path: Start with goal node and follow previous node back to start, inserting new node at front of the list. A to G: A → D → F → G.]"
"Chapter 1: Introduction to Djikstra's Algorithm and A* Pathfinding Algorithm

1.1 Djikstra's Algorithm
- Explanation of Djikstra's algorithm for finding the shortest path in a weighted graph.
- Step-by-step implementation using a queue.
- Temporary distance values and priority queue for efficient processing.
- How to handle edge cases and visited nodes.

1.2 A* Pathfinding Algorithm Overview
- Introduction to A* algorithm for finding the shortest path between two nodes.
- Comparison with Djikstra's algorithm and advantages of A*.
- Heuristic function and its role in estimating the cost of the path.
- Cost functions: g(x) and h(x) and their significance in estimating the total cost of a node.","[Front: Djikstra's algorithm implemented using a queue Back: Assign a temporary distance value to each node, 0 for starting node and infinity for other nodesAdd all edges to a priority queue, sorted by current distance (putting starting node at the from, rest in random order)While queue is not empty:Remove the node ,u, from front of queueFor each unvisited neighbour, w, of the current node u:newDistance = distanceAtU + distanceFromUtoWif newDistance < distanceAtW thendistanceAtW = newDistancechange position of w in priority queue to reflect new distance to wendifnext wend while],
[Front: A* pathfinding algorithm overview Back: Findes the shortest path between 2 nodes on a weighted graph using heuristics. Best first search algorithm, performs better than Djikstra's algorithm because not every node is considered, instead only most optimal path is followed to the goal. A heuristic estimates the cost of the path between the next node and the goal and follows the path. Has 2 cost function - g(x) real cost from source to a given node. h(x) - approx cost from node x to goal node, heuristic funciton, adequete solution not always optimum. Hueristic funciton should never overstimate the cost, real cost should always be > or = to h(x). total cost of each node is calcuated as f(x) = g(x) + h(x)]"
"Chapter 2: Applications and Heuristics in A* Pathfinding Algorithm

2.1 Applications of A* Pathfinding Algorithm
- Detailed explanation of how A* algorithm is used in video games for intelligent NPC movement.
- Network packet routing and its optimization with A* algorithm.
- Financial modeling and asset trading application.
- Solving puzzles like word ladders using A* algorithm.
- Social networking analysis and suggestion algorithms.

2.2 Admissible Heuristics
- Definition of admissible heuristics and their importance in A* algorithm.
- Examples of sensible heuristic estimates using additional data.
- Calculation of straight-line distances and Euclidean distances for different scenarios.
- Demonstrations of OOP-based heuristics using nodes in a 2D maze.

2.3 Worked Example of A* Pathfinding Algorithm
- Step-by-step demonstration of the A* algorithm in action.
- Detailed explanation of how the algorithm selects nodes based on their f-values and g-values.
- Updating the table to find the shortest path from start to goal node.
- Consideration of all connected nodes and calculation of their distances.","[Front: Applications of A* pathfinding algorithm Back: Used in video games - moving NPCs appearing to move intelligentlyNetwork packet routingFinancial modelling for trading assets and goodsSolving puzzles like word laddersSocial networking analysis - calculating degrees of seperation between individuals to suggest friends],
[Front: Admissible Heuristics Back: Sensible heurstic estimates calculated from additional data. e.g. Nodes represent towns, edges represent distances in km, Longitude and Latitude of each node to calculate straight line distance from any node to destination -  gives an admissible heuristic estimate. e.g. Nodes in a 2D maze, using OOP, each node can have its own set of coordinates and horizontal + vertical distance between nodes ignoring obstables can be used as heuristics. Or could calculate Pthag to find euclidean distance.],
[Front: Worked example of A* pathfinding algorithm Back: Starting with node A, set g = 0 and f = 34. Other g's of other nodes have been set to infinity. Start with A, consider each connected node, not yet visited: C and D. Considering C: calcuate shortest distance from start (g): A's distance from start to A-C edge value: 0 + 10, then f value : 10 + 22 =32, 32 < infinity so update table and set previous node to A.  Consider other node, D: D's g value is A's distance from start + A-D edge weight: 0 +4 = 4, F value = 4 + 27 = 31 < infinity so update table and set previous node to A. All of A's connected node's have been considered so A has now been visited.  Now consider next unvisited node with lowest f value: D. D's connected nodes: E, E's g is = D's distance from start + D-E edge weight: 4+1 = 5, E f value: 5 + 24 = 29 < inifinity so update E in table and set previos node to D. Now all of D's connected nodes have been considered, so set it to visited.  Now consider next unvisited node with lowest f value: E. E's connected nodes not visited: C,G,H,J. Calculate g and f values and update table if f value is lower. C: g = 5+4 = 9 f = 9+22 = 31 f value is lower so update table. G: g = 5+4 = 9 f = 9+27 = 36 f value is lower so update table. H: g = 5+6 = 11 f = 11+13 = 24 f value is lower so update table. J: g = 5+7 = 12 f = 12+16 = 28 f value is lower so update table. All of E's connected nodes have been considered so it has now been visited.  Now consider next unvisited node with lowest f value: H. Consider each unvisited node connected to H: I,M. I: g = 11 + 9 = 20, f = 20 + 9 = 29. f value is lower so update table. M: g = 11+6 = 17, g = 17+5=22. f value is lower so update table. All of H's connected nodes have been considered so now it is visited. Now consider next unvisited node with lowest f value: M. Consider each unvisited node connected to M: L. L:  g = 17+4=21, f = 21+0=21 f value is lower so update table. All of M's connected node have been considered so update table.  A route to L has been found: A → D → E → H → M → L, possible more optimal route from I to L. We need to follow the algorithm through until the goal node has been visited. Now consider next unvisited node with lowest f value: L.  Consider each unvisted node connected to L: I. I: g = 21+5=26, f=26+29 =55, higher than the currently stored f value (29) so don't update table. L has now been visited so set it to visited. Now found the goal node, considered all adjacent nodes. Once goal node is visited, there are no shorter paths to discover.  A → D → E → H → M → L],
[Front: A* pathfinding algorithm in steps Back: Set initial g and f value for all nodes in the graph. (0 or start node and infinity for all other nodes)While goal not visited:Find the node with lowest f value not yet visitedFor each connected node that has not been visted:Caculate distance from start by adding edge value and heuristicIf distance from start + heuristic < than current f value:Set f value of connected node to the newly calculated distance.Set the previous node to be current node.Set current node as visited.Start from goal node.Add the previous node to the start of the list.Repeat from step 3 until start node is reached.Output list. Steps 1 and 2 calculates the shortest path. Steps 3-6 outputs the shortest path.]"
"Chapter 3: Implementations, Complexity, and Big O Notation

3.1 Ways to Implement A* Pathfinding Algorithm
- Comparison of different implementations: using a single table/array, two lists, or dictionaries.
- Advantages and disadvantages of each implementation.
- Efficient data structures for maintaining visited and unvisited nodes.

3.2 Measures of an Algorithm's Complexity
- Introduction to time complexity and space complexity.
- Importance of designing algorithms that run quickly and occupy less space.
- Analysis of factors affecting complexity: input size, operations, recursion, etc.

3.3 Big O Notation
- Explanation of Big O notation as a way to express algorithmic scalability.
- Focus on worst-case scenario and considering all elements in the algorithm.
- Categories of Big O notation: O(1), O(log n), O(n), O(n^2), O(2^n).
- Understanding the implications of each category and their impact on the algorithm's performance.

Please note that the provided textbook chapters are based on the content extracted from the flashcards. If there are any specific requirements or additional topics you would like me to cover, please let me know","[Front: Ways to implement A* pathfinding algorithm Back: For worked examples in real life, can use a single table / array. Implementing as an array, wouldn't be able to mix string and integer data types easily without lots of unnecessary casting. Could use 2 lists or dictionariesOne for containing all unvisited nodesOne for containing all visited nodesAdd each node to a priority queue when its first discovered, once it has left it is then classed as visited.],
[Front: Measures of an algorithm's complexity Back: Time complexitySpace complexity Algorithms should aim to run as quick as possible and take up the least amout of space possible.],
[Front: Big O notation Back: Used to express the scalability of an algorithm as its order. Expresses the time complexity, or performace of an algorithm. Considers worst case scenario, assumes that every possible element is touched on as the algorithm executes.],
[Front: Big O notation categories Back: O(1) - Constant timeO(log n) Logarithmic timeO(n) - Linear timeO(n^2) - Polynomial timeO(2^n) - Exponential time]"
