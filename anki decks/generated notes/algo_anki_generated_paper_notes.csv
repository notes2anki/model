"- Linear Search Overview: 
  - Linear search finds an item in a (un)sorted list by starting at the first item and checking each item one by one. It does not require the data set to be in order and can be efficient for smaller data sets. However, it becomes inefficient for larger data sets.

- Applications of Linear Search:
  - Linear search is ideal for finding items in small data sets and searching unordered data such as a settings file. It is commonly used in functions like find and replace in word processors. It is the easiest search algorithm to implement but usually the most inefficient.

- Linear Search Pseudocode:
  - The pseudocode for linear search is as follows:
    - Initialize variables: found = False, index = 0
    - Enter a while loop while found is False and index is less than the length of the items list:
      - If items[index] is equal to the itemToFind:
        - Set found to True and exit the loop.
      - Else, increment index by 1.
    - End the while loop.

- Linear Search Algorithm Must:
  - The linear search algorithm must:
    - Be able to locate an item in a data set if it exists.
    - Be able to locate the item regardless of whether the data set is sorted or not.
    - Run without crashing even if the item being searched for doesn't exist in the data set.
    - Check each item sequentially starting with the first item.

- Limitations of Coded Linear Search:
  - The coded linear search version exits as soon as the first occurrence of the item is found. This means it does not find the first, last, or all occurrences of the item, which may be required in some scenarios.","[Front: Linear Search overview Back: Finds an item in a(n) (un)sorted list. Starts at the first item and checks each item one by one. Doesn't required the data set to be in order Can be efficient for smaller data sets Inefficient for large data sets],
[Front: Applications of linear search Back: Ideal for finding items in small data sets and searching unoredered data such as a settings file. Typical use of linear search would be a find and replace function in a word processor Easiest search algorithm to implement but usually most inefficient.],
[Front: Linear search psuedocode Back: found  = False index = 0  # start by initialising variables with their starting state. # ""found"" Boolean value is used to indicate whether the item we are searching fro has been found or not - start with False. # ""index"" specifies current position in the data set, starting at 0, we will assume the data being searched is stored in array or list. While found == False and index < items.Length #We enter a While loop that will continue to execute while found is False and index is less than the lengh of the items list.            If items[index] == itemToFind then #Each time around the loop, the program checks to see if the current item is the one we are searching for.                found = True #if it is, then Found is set to true causing the exit of the loop at the start of next iteration            Else                index = index + 1 #if it isn't then increment index by 1, meaning next iteration of the loop, the program will be checking against the next location the data set.            End IF  End While],
[Front: Linear search psuedocode without comments Back: found = False index = 0   While found == False and index < items.Length            If items[index] ==  itemToFind then                found = True            Else                index = index + 1            End If End While],
[Front: Linear search algorithm must: Back: Be able to locate an item in a data set if it exists Be able to locate the item regardless of whether the data set is sorted or not. Run without crashing even if the item being searched for doesn't eexist in the data set. Check each item sequentially starting with the first item.],
[Front: Limitations of coded linear search: Back: Version exits as soon as the first occurence of the item is found What if you wanted to find the first, last or all occurences?],
[Front: Binary search overview Back: Efficient algorithm for finding an item in a sorted data set. More efficient than linear search. Starts at the middle of the list and repeatedly divides the list in half Requires the data set to be sorted first e.g. numerical or alphabetical order Efficient for large data sets],
[Front: Applications of binary search Back: Ideal when you need to search for an item in a large sorted data set e.g.  online dictionary where words are sorted in alphabetical orderAs it discards half of the data after each iteration, it quickly reduces the very large data sets containing millions of records to one much more manageable.]"
"- Binary Search Overview:
  - Binary search is an efficient algorithm for finding an item in a sorted data set. It starts at the middle of the list and repeatedly divides the list in half, discarding the irrelevant half at each iteration. It requires the data set to be sorted in numerical or alphabetical order and is efficient for large data sets.

- Applications of Binary Search:
  - Binary search is ideal when you need to search for an item in a large sorted data set, such as an online dictionary where words are sorted in alphabetical order. As it discards half of the data after each iteration, it quickly reduces the search space in very large data sets containing millions of records.

- Binary Search Pseudocode:
  - The pseudocode for binary search is as follows:
    - Initialize variables: found = False, first = 0, last = items.length - 1
    - Enter a while loop while first is less than or equal to last and found is False:
      - Calculate the midpoint of the data set: midpoint = (first + last) DIV 2
      - If items[midpoint] is equal to the itemToFind:
        - Set found to True and exit the loop.
      - Else, if items[midpoint] is less than the itemToFind:
        - Adjust the value of first to be midpoint + 1.
      - Else, adjust the value of last to be midpoint - 1.
    - End the while loop.","[Front: Psuedocode binary search Back: found = False first  =  0 last = items.length - 1 #found is used to indicate whether the item we are searching for has been found or not- seting it to false #first/last: with each iteration, we need to know the curretn index of the first and last item in data set so we can find the mid point. MP changes with each iteration. To start with, we will be searching the entire data set, so set ""first"" to index 0 and ""last"" to length of data set - 1 which will be the index of the last item.  While first <= last and found == False #Enter a while loop that continue to iterate providing both first <= last and found == False. Loop will iterate until item is found or entire data set has been searched.       midpoint = (first + last) DIV 2 #Calculate the MP of data set. Add index values in ""first"" and ""last"" and do floor division to get an integer.       IF items[midpoint] == itemToFind then #Each iteration, program checks if the item at the MP of the data set is the one we are searching for.           found = True #if it is, ""found"" is set to True and loop will exit at the start of the nnext iteration       Else           If items[midpoint] < itemToFind then #if not then program will check if the MP is less than or greater than the desired item, allowing us to discard half the entire data set. We can do this becuase items in the data set of a binary search are stored in order.              first = midpoint + 1 #if item at MP is less than the desired value, we adjust ""first"" to point at the index value in MP + 1           Else               last = midpoint = 1 #if item at MP is more than the desired value, we adjust ""last"" to point at the index value in MP - 1 #Repeat while loop until we find desired item or prove that item is not in data set.           End If        End If End While]"
"- Bubble Sort Overview:
  - Bubble sort is a sorting algorithm that sorts an unordered list of items by comparing each item with the next one and swapping them if the current item is greater. This process is repeated until no more swaps can be made. The largest or smallest item bubbles up to the end of the list after each pass. Bubble sort is the most inefficient sorting algorithm, but it is easy to implement and is a popular choice for very small data sets.

- Applications of Bubble Sort:
  - Bubble sort is most suitable for situations where a simple, easy-to-implement sorting algorithm is required. It is not efficient for larger data sets but works well for very small data sets.

- Bubble Sort Pseudocode:
  - The pseudocode for bubble sort is as follows:
    - Initialize variables: n = items.length, swapped = True
    - Enter a while loop while n is greater than 0 and swapped is True:
      - Set swapped to False.
      - Decrement the value of n by 1.
      - Enter a nested inner for loop from index 0 to n - 1:
        - If items[index] is greater than items[index+1]:
          - Swap items[index] with items[index+1].
          - Set swapped to True.
      - Continue through the data set, moving the item up as far as it needs to go until it is in the correct place.
    - End the while loop.

- Insertion Sort Overview:
  - Insertion sort is a sorting algorithm that inserts each item into its correct position in a data set one at a time. It is particularly useful for small data sets and is efficient for inserting items into an already sorted list. However, it becomes inefficient for larger data sets.

Note: The paper notes have been generated as per the information provided in the flashcards","[Front: Binary seach psuedocode without comments Back: found = False first = 0 last = items.Length -1  WHILE first <= last and found == False         midpoint = (first+last) DIV 2         IF items[midpoint] == itemToFind then             Found = True         Else           IF items[midpoint] < itemToFind then               first = midpoint + 1           Else                last = midpoint - 1           End IF         End If End While],
[Front: Bubble sort overview: Back: Sorts an unordered list of items by comparing each item with the  next one and swapping the items if it is greater than it. Algorithm is finished when no more swaps can be made. It bubbles the largest or smallest up to the end of the list. Last element will be in correct place after first pass.],
[Front: Applications of bubble sort Back: Most inefficient sorting algorithm Easy to implement Popular choice for very small data sets Ideal for situations where a simple easy to program sorting  algorithm is required.],
[Front: Bubble sort psuedocode Back: n = items.length swapped  = True # ""n"" used to track how far through the data set we need to check for items to swap on each iteration. start by setting it to then length of the data set.  #""swapped"" used to indicate whether a swap has taken place each iteration of the inner for loop. start by setting it to true so we will enter the main WHILE loop at least once to check for unsorted items. WHILE n > 0 AND swapped == True #enter a while loop which will iterate while n>0 and swapped == True. Loop will iterate until all items are sorted           swapped = False #each iteration the while loop assumes there are no items that need to be swapped until we prove otherwisw, so we set ""swapped"" to false.           n = n -1 #ensures that the length of the list is inline with 0 indexing. Ensures that the entire data set will be checked the first iterations for items to swap. This value will decrement by 1 each iteration of the outer WHILE loop. Sorted items will gradually, bubble up to the end of the data set so there will be fewer items to check through each iteration.           For index = 0 To n-1 #nested inner for loop. for each pass through the data set, respresented by the while loop, we need to start through the beginning and work through to the penultimate item of the unsorted data set, represented by n - 1. Need to work through the current subset of items that still need to be check.                If items[index] > items[index+1] then #if we find that the item at the current location in the data set is greater than the next item, we know it is out of order                    Swap(items[index] , items [index+1])                    swapped = True #we then swap the 2 items, then set ""swapped"" to true so that when we next check the outer while loop, we know we are still in the process of sorting the data out.                  End IF            End For #continue through the data set moving the item up as far as it needs to go until it is in the correct place. End WHILE #process is repeated as many times necessary until we discover the entire data set has been sorted.],
[Front: bubble sort pseudocode without comments Back: n = items.Length swapped = True  While n > 0 AND swapped == True           swapped = False           n = n -1           For index = 0 TO n-1                  If items[index] > items[index+1] then                     Swap(items[index] , items[index+1])                     swapped = True                 End if           End For End While],
[Front: Insertion sort overview: Back: Inserts each item into its correct position in a data set one at a  time. Useful for small data sets. Partically useful for inserting items into a ready sorted list Inefficient for larger data sets.]"
"Insertion Sort Pseudocode:
- For index = 1 TO items.Length:
    - current = items[index]
    - index2 = index
    - While index2 > 0 AND items[index2-1] > current:
        - items[index2] = items[index2 - 1]
        - index2 = index2 - 1
    - End While
    - items[index2] = current
- End for

Inefficiencies of Insertion Sort:
- Insertion sort requires moving all the items in the data structure to insert the ""current"" item into its new location.
- This process needs to be repeated again and again, especially with larger and poorly sorted data sets.
- Using a linked list could have eliminated the need to move items within the data structure.

Stacks:
- Stacks are a Last-In-First-Out (LIFO) data structure.
- Items are pushed onto the top of the stack when added and popped off the top when deleting.
- Peeking at the top allows us to look at the top item without deleting it.
- Stack overflow occurs when trying to push an item onto a full stack, and stack underflow occurs when trying to pop an item off an empty stack.
- Stacks are often implemented using an array but can also be created using object-oriented programming.","[Front: Insertion sort psuedocode Back: For index = 1 TO items.Length: #algorithm sets a for loop to iterate through the data set #it compares the item in items[1] with item immediately before it, at items[0]. This is why the for loop starts at 1 not 0, if we started at 0, we would be trying to compare the very first item in the data set with one at position items [-1] which would cause an out of bounds error.        current = items[index] #first thing we do each iteration is take a copy of item we are sorting and place it in temporary ""current"". We do this because if we  find items before it are wrong order, we will need to move them  up in the data set. In doing this we would override the original  term and we need a way of getting back to insert it into its current location.        index2 = index #set index2 to be same value as index 1. index2 used to track where we need to exit inner While loop. Every iteration of outer FOR loop, we need to check the current item against items before it. As we iterate through the data set, this number increases.          While index2 > 0 AND items[index2-1] > current #inner while loop is executed if any additional items before the one one we are comparing that still needs to be checked with index2 > 0 AND we check if that the item is greater than the one we are comparing, if it is, then we know the items are out of place.                items[index2] = items[index2 - 1]                index2 = index2 - 1 #Here we move the item up by 1 space and decrement index2 by 1. Then we check again to see if the item is in the correct place. If still not in the correct place, we repeat the while loop, moving all the items before the one we are comparing up one place till we discover the correct location.        End While #drop out of the while loop.          items[index2] = current #take a copy of the item we are comparing held in current, place the copy in its correct location. #outer for loop now increments and the whole process repeats. This time we are trying to locate the correct position of the next item.  End for],
[Front: insertion sort pseudocode without comments Back: For index = 1 TO items.Length :       current = items[index]        index2 = index         While index2 > 0 AND items[index2 - 1] > current              items[index2] = items[index2 -1]              index2 = index2 - 1        End While           items[index2] = current End For],
[Front: Inefficienies of insertion sort Back: Having to move all the items in the data structure so we can insert the ""current"" item into its new location - only to find that we need to repeat the process again and again. Gets worse with larger data sets and if data is poorly sorted already when inserting.  Could have used a linked list which would negate the need to move items within the data structure. Instead we would need to update various pointers linking nodes together to reflect new structure  each iteration.],
[Front: Stacks Back: Items are pushed onto the top of the stack when added Popped off the top when deleting Peek  = look at top without deleting Last in First out Structure Last pushed on must be first popped off stack pointer always points to the node on the top any attempt to push an item onto a full stack is called a stack  overflow any attempt to pop an item of an empty stack is called stack  undeflow Often implemented using an array can also be created using OOP.]"
"Queue:
- Queues are a linear data structure.
- Items are enqueued at the back and dequeued from the front.
- Peeking at the front allows us to look at the front item without deleting it.
- Priority queue allows certain items to join the front of the queue.
- Queue overflow occurs when trying to enqueue items to a full queue, and queue underflow occurs when trying to dequeue an empty queue.
- Queues can be implemented using an array or object-oriented programming.

Implementation of Pushing onto a Stack using a Static Array:
1. Check if the stack is full and output an error if it is.
2. Increment the stack pointer.
3. Insert the new data item at the location pointed to by the stack pointer.
- Function isFull(top):
    - if top == maxSize - 1 then
        - return true
    - else
        - return false
    - end if
- Procedure push(stack, top, data):
    - if isFull(top) == True then
        - print(""stack is full"")
    - else
        - top = top + 1
        - stack[top] = data
    - end if
    - return top
- End procedure

Implementation of Pushing onto a Stack using OOP and a Linked List:
- Class Node:
    - private data
    - private next
    - public procedure new(newItem):
        - data = newItem
        - next = Null
    - end procedure
    - public function getData():
        - return data
    - end procedure
    - public function getNext():
        - return next
    - end procedure
    - public procedure setNext(newNext):
        - next = newNext
    - end procedure
- End class
- Class Stack:
    - private top
    - public procedure new():
        - top = Null
    - end procedure
- End class

Measurements of Algorithm Efficiency:
- Time complexity refers to how much time an algorithm needs to solve a problem.
- Space complexity refers to the amount of resources (memory) an algorithm requires.

Comparing Linear and Binary Search on a Large Data Set:
- Linear search does not require items to be stored in order, while binary search requires items to be in order.
- Linear search starts at the first item and searches each item in sequence until the item is found or there are no more items.
- Binary search starts at the middle item and halves the set of items to search after each comparison until the item is found or there are no more items.
- Linear search can be implemented using an array or linked list, while binary search can be implemented using an array or binary tree.
- Linear search is suitable for a small number of items, while binary search is suitable for a large number of items.

Merge Sort Overview:
- Merge sort is an efficient sorting algorithm that uses the divide and conquer principle.
- The divide and conquer principle involves creating 2 or more identical subproblems from the larger problem, solving them individually, and combining their solutions to solve the overarching problem.
- Merge sort divides the unsorted list into n sublists, each containing one element.
- It repeatedly merges sublists to produce new sorted sublists until there is only one sublist remaining, which is the sorted list.

Applications of Merge Sort:
- Merge sort is suitable for any data set but works best with large ones where memory is not a concern.
- The time taken to perform the sort should be minimized.
- Merge sort is ideal for parallel processing environments where the concept of divide and conquer can be utilized.

Merge Sort Steps:
1. Repeatedly divide the list in half until each item is in its own list.
2. Take 2 adjacent lists and start with the first item in each one.
3. Compare the 2 items and insert the lowest item into a new list. Move to the next item in the list it was taken from.
4. Repeat steps 3 and 4 until all the items from one of the lists are in the new list.
5. Append all the items from the list that still contains items to the new list.
6. Replace 2 adjacent lists with the new list.
7. Repeat from step 2 until all adjacent lists have been compared.
8. Repeat from step 2 until only one list remains.
- Steps 3 to 6 take place inside the merge function.","[Front: Queue Back: Linear data structure Enqueued at the back Dequeued from the from can peek at the fron without deleting it priority queue -  certain items can join the front of the queue First in First out structure back/tail pointer always points to the last item in the queue front/head pointer - points to the first attempts to enqueue items to a full queue is queue overflow dequeue an empty queue is queue underflow Can be implemented using an array or OOP.],
[Front: Implementation of pushing onto a stack using a static array Back: 1. check the stack and output and error if its ful 2. increment the stack pointer insert the new data item at the location pointed to by the stack  pointer  function isFull(top)     if top == maxSize - 1 then           return true     else          return false     end if end function  procedure push(stack, top, data)          if isFull(top) == True then             print(""stack is full"")          else              top = top + 1              stack[top] = data           end if           return top end procedure],
[Front: Implementation of pushing onto a stack using OOP and a linked list Back: class Node        private data        private next         public proecdure new(newItem)           data  = newItem           next = Null        end procedure         public function getData()           return data        end procedure              public function getNext()           return next        end procedure         public procedure setNext(newNext)              next = newNext        endprocedure  public procedure push (data)          newNode = Node(data)           if top != Null then               newNode.setNext(top)           end if           top = newNode end proecedure  end class  class Stack        private top         public procedure new()                  top = Null        end procedure  end class],
[Front: Measurements of algorithm efficiency Back: Time complexity - how much time they need to solve a problem Space complexity - Amound of resources they require],
[Front: Comparing linear and binary search on a large data set. Back: Linear Binary                 Items do not need to be stored in order Items must be in order for the algorithm to work Start at the first item start at the middle item Search each item in sequence until each item is found or there are no items to  check halves the set of items to search after each comparison until the item is found or there are no more items to check - Divide and Conquer reduces data set by half each iteration. Can be implemented using an array or linked list Can be implemented using an array or binary tree new items are added at the end - quick New items must be added in the correct place to maintain the order of items - can be slow suitable for small number of items Suitable for a large number of items],
[Front: Merge Sort overview Back: Can sort a data set extremely quickly using divide and conquerPrinciple of divide and conquer is to create 2 or more identical subproblems from the larger problem, solve them individually and combine their solutions to solve the overaching problem.Divide the unsorted list into n sublists, each containing one element.Repeatedly merge sublists, to produce new sorted sublists until there is only sublist remaining, being the sortest list.],
[Front: Applications of merge sort Back: Suitable fot any data sets but works best with large ones where memory is not a concern However, the time take to perform the sort should be minimised. Ideal for parallel processing environments where the concept of divide and conquer can be used.],
[Front: Merge sort steps Back: Repeatedly divide the list in half until each item is in its own list Take 2 adjacent lists and start with the first item in each one Compare the 2 items Insert the lowest items into a new list. Move to the next item in the list it was taken from Repeat steps 3 and 4 until all the items from one of the lists are in the new list Append all the items from the list that still contains items to the new list Replace 2 adjacent lists with the new listRepeated from step 2 until all adjacent lists have been compared Repeat from step 2 until only one list remains Steps 3 to 6 take place inside the merge function]"
"Merge Sort Pseudocode Step 1:
- Repeatedly divide the list in half until each item is its own list.
- Main algorithm starts here:
- items = [""Florida"", ""Georgia"", ""Delaware"", ""Alabama""]
- listOfItems = []
- item = []
- For n = 0 TO items.length - 1:
    - item = items[n]
    - listOfItems.append(item)
- End for
- listOfItems contains a set of lists that all contain a single item.

Merge Sort Pseudocode Step 2:
- Take 2 adjacent lists and start with the first item in each one.
- Repeat while there is more than one list:
    - index = 0
    - While index < listofItems.Length - 1:
        - newList = merge(listOfItems[index], listOfItems[index+1])
        - Function merge(list1, list2):
            - newList = []
            - index1 = 0
            - index2 = 0
- End while

Merge Sort Pseudocode Step 3:
- Compare the 2 items and insert the lowest item into a new list, move to the next item in the list it was taken from.
- Repeat steps 3 and 4 until all the items from one of the lists are in the new list:
    - While index1 < list.Length and index2 < list2.Length:
        - If list1[index1] > list2[index2] Then
            - newList.append(list2[index2])
            - index2 = index2 + 1
        - Else if list1[index1] < list2[index2] Then
            - newList.append(list1[index1])
            - index1 = index1 + 1
        - Else if list1[index1] == list2[index2] Then
            - newList.append(list2[index2])
            - index2 = index2 + 1
            - newList.append(list1[index1])","[Front: Merge sort psuedocode step 1: Repeatedly divide the list in half until each item is its own list. Back: #main algorithm starts here items = [""Florida"" ,""Georgia"",""Delaware"",""Alabama""] listOfItems = [] item = [] #every item is put into its own list with a containter list  for n = 0 TO items.length - 1       item = items[n]       listOfItems.append(item)  #listOfItems contains a set of lists that all contain a single item],
[Front: Merge sort psuedocode step 2: Take 2 adjacent lists and start with the first item in each one Back: #Repeat while there is more than one list While listOfItems.Length != 1           index = 0           #Merge pairs of lists           While index < listofItems.Length - 1               newList = merge(listOfItems[index], listOfItems[index+1])  #function to merge 2 lists into a new list Function merge(list1, list2)          newList = []          index1 = 0          index2 = 0],
[Front: Merge sort psuedocode step 3: Compare the 2 items and step 4: insert the lowest item into a new list, move from the next item in the list it was take from. Step 5: Repeat steps 3 and 4 until all the itmes from one of the lsits are in the new list. Back: #Check each item in each list, and add the smallest item to a new list  While index1 < list.Length and index2 < list2.Length          If list1[index1] > list2[index2] Then             newList.append( list2[index2])             index2 = index2 + 1          Else if list1[index1] < list2[index2] Then             newList.append(list1[index1])             index1 = index1 + 1           Else if list1[index1] == list2[index2] Then             newList.append( list2[index2])             index2 = index2 + 1             newList.append(list1[index1])             index1 = index1 + 1           End if End While #the process needs to be repeated until all the items from one of the lists have been put into the ""newList""],
[Front: Merge sort step 6: Append all of the items from the list that still contains items to the newList Back: #add left over items from the remaining list If index1 < list.Length Then     For item = index1 to list1.Length            newList.append(list1[item])     Next item Else if index2 < list2.Length Then     For item = index2 to list2.Length           newList.append (list2[item)     Next Item End if Return newList  #main program newList = merge(listOfItems[index], listOfItems[index+1]],
[Front: merge sort Step 7: replace 2 adjacent lists with the new list step 8: repeat from step 2 until all adjacent lists have been compared. 9: Repeat from step 2 until only one list remains. Back: #repeat while there is more than one list While listOfItems.Length != 1        index = 0        #Merge pairs of lists        While index < 1 list of items.Length - 1                 newList = merge(listOfItems[index], listofItems[index+1])                 listofItems[index] = newList                 #once merged, delete one of the now redunant lists                 del listOfItems[index+1]                  index = index + 1         End while End while],
[Front: Linear search psuedocode from textbook Back: ]"
"1. Applications of insertion sort:
   - Useful for small data sets.
   - Particularly useful for inserting items into a ready sorted list.

2. Merge sort process graphically: (Missing information)

3. Merge sort textbook pseudocode: (Missing information)

4. Quick sort overview:
   - Orders a data set extremely quickly using divide and conquer.
   - Uses a pivot value from the data set against which other items are compared to determine their position.
   - Typically requires less memory than merge sort.

5. Applications of quick sort:
   - Suitable for any data set, but more for larger data sets.
   - Ideal for parallel processing environments where divide and conquer can be used.
   - Used in: Medical monitoring, Life support systems, Aircraft controls, Defense systems.

6. Quick sort steps:
   - Select a value to be the pivot value, which is used to compare values.
   - The final position of the pivot value is called the split point, which is used to divide the list for subsequent calls.
   - Select a left mark and right mark, the beginning and end of the remaining items in the list.
   - If the left mark is less than the pivot value, move the left mark pointer to the right until you find a left mark value greater than the pivot.
   - If the right mark pointer is greater than the pivot value, move the right mark pointer to the left until you find a right mark value less than the pivot.
   - Exchange the left mark and right mark values.
   - Continue with the left mark and right mark moving process.
   - Once the left mark and right mark have crossed, stop the moving process.
   - Swap the pivot value for the location where the process stopped (split point).
   - The left-hand side (LHS) of the split point contains values less than the pivot, and the right-hand side (RHS) contains values greater than the pivot.
   - The list can be divided at the split point, and quick sort is invoked recursively on the two halves.

7. Quick sort pseudocode: (Missing information)","[Front: Applications of insertion sort Back: Useful for small data sets Particularly useful for insterting items into a ready sorted list.],
[Front: Merge sort process graphically Back: ],
[Front: Merge sort textbook psuedocode Back: ],
[Front: Quick sort overview Back: Orders a data set extremely quickly using divide and conquer Uses a pivot value from the data set which other items are compared against to determine their position. Typically requires less memory than merge sort.],
[Front: Applications of quick sort Back: Suitable for any data set but more for larger data sets. Ideal for parallel processing environments where divide and conquer can be used. Used in: Medical monitoringLife support systemsAircraft controlsDefence systems],
[Front: Quick sort steps Back: Select a value to be pivot value. Used to compare values. Final position of pivot value is called split point which is used to divide the list for subsequent calls. Select a leftmark and right mark, beginning and end of remaining items in list. If the leftmark is less than pivot value, move leftmark pointer to the right till you find a leftmark value greater than pivot.If the rightmark pointer is greater than pivot value, move rightmark pointer to left till you find a rightmark value less than pivot.Exchange leftmark and rightmark values.Continue with leftmark rightmark moving process.Once leftmark and right mark have crossed, stop moving process.Swap pivot value for the place stopped (split point).LHS of split point is less and RHS is greater, list can be divided at split point and quick sort invoked recursively on 2 halves.],
[Front: Quick sort psuedocode Back: ]"
"1. Advantages of quick sort:
   - Extremely fast.
   - If the partition always occurs in the middle of the list, there will be log n divisions in a list of length n.
   - Each of the n items needs to be checked against the pivot value to find the split point.
   - Time complexity: O(n log n).
   - Doesn't need additional memory.","[Front: Advantages of quick sort Back: Extremely fast. If partition always occurs in middle of the list there will be log n divisions in a list of length n, and each of the n items need to be checked against pivot value to find split point. O(n log n). Doesn't need additional memory.]"
"1. Disadvantages of quick sort:
   - If the split points are not near the middle of the list but close to the start or end, the division will be uneven.
   - For example, if the split point is the first item in a list, the division results in a list of 0 items and a list of n-1 items.
   - The list of n-1 items divides into 0 items and n-2 items, and so on.
   - This results in a time complexity of O(n^2).
   - If the list is large and recursion takes too long, it may cause a stack overflow and the program will crash.

2. Dijkstra's shortest path algorithm overview:
   - Finds the shortest path between one start node and all other nodes on a weighted graph.
   - A type of breadth-first search.

3. Disadvantage to Dijkstra's shortest path algorithm:
   - Doesn't work for edges with a negative weight value","[Front: Disadvantages of quick sort Back: If split points are not near the middle of the list, but close to start or end, division will be uneven. If split point is first item in a list, division results in a list of 0 items and a list of n-1 items. List of n-1 items divides into 0 items and n-2 items and so on. Resulting in time complexity O(n^2) If list is large and recursion takes too long, may cause stack overflow and program will crash.],
[Front: Djikstra's shortest path algorithm overview Back: Find's the shortest path between one start node and all other nodes on a weighted graph. A type of breadth first search.],
[Front: Disadvantage to Djikstra's shortest path algorithm Back: Doesn't work for edges with a negative weight value.]"
"- Difference between Djikstra's and A*: A* uses heuristics while Djikstra's does not.
- Applications of Djikstra's: Used for purposes such as finding the shortest path between two points (e.g., GPS navigation, IP routing, telephone networking).
- Ways to implement Djikstra's: Using a table or array, queues, and a series of lists.
- Djikstra's shortest path steps: Set temporary distances from start value for all nodes (0 for start node and infinity for others). For each node in the graph, find the node with the shortest distance from the start that hasn't been visited. For each connected node that hasn't been visited, calculate the distance from the start. If the distance from the start is lower than the currently recorded distance from the start, update the shortest distance to the start of the connected node. Set the previous node to be the current node and mark the node as visited. Repeat until the start node is reached. Output the shortest path.
- Worked example of Djikstra's using a table: Find the node with shortest distance from start that hasn't been visited. Calculate distance from start to each connected node, compare with current recorded distances, and update if lower. Repeat until all nodes are visited. Output the shortest path.
- Djikstra's algorithm implemented using a queue: Assign a temporary distance value to each node (0 for starting node and infinity for other nodes). Add all edges to a priority queue, sorted by current distance. While the queue is not empty, remove the node with the lowest distance from the front of the queue. For each unvisited neighbor of the current node, calculate the new distance. If the new distance is lower than the current distance, update the distance and change the position of the node in the priority queue. Repeat until the goal node is visited.
- A* pathfinding algorithm overview: A* finds the shortest path between two nodes on a weighted graph using heuristics. It is a best-first search algorithm and performs better than Djikstra's algorithm because it only considers the most optimal path to the goal. A* uses two cost functions: g(x) for the real cost from the source to a given node and h(x) for the approximate cost from the node to the goal. The heuristic function h(x) should never overestimate the cost, and the total cost of each node is calculated as f(x) = g(x) + h(x).
- Applications of A* pathfinding algorithm: Used in video games for moving NPCs, network packet routing, financial modeling for trading assets and goods, solving puzzles like word ladders, and social networking analysis to calculate degrees of separation between individuals and suggest friends.","[Front: Difference between Djikstra's and A* Back: A* uses heuristics while Djikstra's does not.],
[Front: Applications of Djikstra's Back: Used for purpose to find the shortest path between 2 points e.g.: GPS navigationIP routingTelephone networking],
[Front: Ways to implement Djikstra's Back: Using a table or array Queues and a series of lists],
[Front: Djikstra's shortest path steps Back: Set temporary distances from start value for all nodes. 0 for start node and infinity for others.For each node in the graph:Find the node with the shortest distance from the start that hasn't been visited.For each connected node that hasn't been visited:calculate distance from startIf the distance from the start is lower than the currently recorded distance from the start:Set the shortest distance to the start of the connected node to the newly calculated distance.Set previous node to be current nodeMark the node as visited.Start from goal node.Add previous node to start of the listRepeat from step 5 until start node reachedOutput list 1 - 3 calculates shortest path 4 - 7 outputs the shortest path from start node to goal node],
[Front: Worked example of Djikstra's using table Back: Find the node with shortest distance from start that hasn't been visited. Which is node A, has a distance of 0 from start node.  Now consider each connected node, not yet visited. B,C,D.  First consider B, calculate distance from start, so A's distance from start + the A to B edge weight: 0 +4 = 4.  Check if B's calculated distance from start is lower than current recorded distance from start: 4 < infinity so update B's distance from start to new distance and set previous node column to be the current node, A.  Now consider C and D. C: 0 +3 = 3. D: 0 + 2 = 2. Both < infinity so update C and D distnace and set previous node to A.  All A's connected nodes have been considered so A can be marked as visited.  Next consider the node with the shortest distance from start that hasn't been visited: D. Consider each node connected to D that hasn't been visited: C and F.  Calculate each nodes distance to start so D's distance from start + B to node's edge weight. C: 2 +1 = 3. This is not less than recorded distance from the start so no update required. F: 2+2 = 4. 4 < inifinity, so update F distance from start. All D connected nodes considered so marked as visited.   Next consider the node with the shortest distance from start that hasn't been visited: C. Consider each node connected to C that hasn't been visited yet. Both A and D have been visited already so, C can be marked as visited.  Next consider the node with the shortest distance from start that hasn't been visited: B or F. Consider B: Consider each node connected to B not visited yet: E. E distance from start: 4 + 4 = 8. 8 < infinity so update E distance from start. Update the previous node we've come from, B. B has had all of its connected nodes considered so mark as visited.  Node with shortest distance from start not yet visited: F. Consider each node connected to F not visited: G. G's distance from start : F's distance from start + F to G edge weight : 4 + 5 = 9. 9 < infinity so update G in table.  Done with F so it is marked as visited.   Node with shortest distance from start not visited: E. Each node connected to E not yet visited: G. G's distance from start: E's distance from start + E to G edge weight: 8 +2 = 10. 10 > 9 so not updated. Finished with E so mark it a visited.  Node with shortest distance from start not yet visited: G. Consider each node conncted to G not yet visited. None so G is marked as visited.  Outputting shortest path: Start with goal node and follow previous node back to start, inserting new node at front of the list. A to G: A → D → F → G.],
[Front: Djikstra's algorithm implemented using a queue Back: Assign a temporary distance value to each node, 0 for starting node and infinity for other nodesAdd all edges to a priority queue, sorted by current distance (putting starting node at the from, rest in random order)While queue is not empty:Remove the node ,u, from front of queueFor each unvisited neighbour, w, of the current node u:newDistance = distanceAtU + distanceFromUtoWif newDistance < distanceAtW thendistanceAtW = newDistancechange position of w in priority queue to reflect new distance to wendifnext wend while],
[Front: A* pathfinding algorithm overview Back: Findes the shortest path between 2 nodes on a weighted graph using heuristics. Best first search algorithm, performs better than Djikstra's algorithm because not every node is considered, instead only most optimal path is followed to the goal. A heuristic estimates the cost of the path between the next node and the goal and follows the path. Has 2 cost function - g(x) real cost from source to a given node. h(x) - approx cost from node x to goal node, heuristic funciton, adequete solution not always optimum. Hueristic funciton should never overstimate the cost, real cost should always be > or = to h(x). total cost of each node is calcuated as f(x) = g(x) + h(x)],
[Front: Applications of A* pathfinding algorithm Back: Used in video games - moving NPCs appearing to move intelligentlyNetwork packet routingFinancial modelling for trading assets and goodsSolving puzzles like word laddersSocial networking analysis - calculating degrees of seperation between individuals to suggest friends]"
"- Admissible Heuristics: Sensible heuristic estimates calculated from additional data. For example, using longitude and latitude to calculate straight line distance, or using coordinates in a 2D maze to calculate the Euclidean distance.
- Worked example of A* pathfinding algorithm: Start with the initial node and calculate g and f values for each node. While the goal node has not been visited, find the node with the lowest f value that has not been visited. For each connected node that has not been visited, calculate the distance from the start and update the f value if necessary. Repeat until the goal node is visited. Output the shortest path.
- A* pathfinding algorithm in steps: Set initial g and f values for all nodes. While the goal node has not been visited, find the node with the lowest f value that has not been visited. For each connected node that has not been visited, calculate the distance from the start and update the f value if necessary. Set the previous node to be the current node and mark the current node as visited. Repeat until the start node is reached. Output the shortest path.
- Ways to implement A* pathfinding algorithm: Use a single table or array, but mixing string and integer data types may be challenging. Alternatively, use two lists or dictionaries: one for unvisited nodes and one for visited nodes. Add each node to a priority queue when it is first discovered, and remove it from the priority queue when it is visited.
- Measures of an algorithm's complexity: Time complexity and space complexity. Time complexity measures how the algorithm's performance scales with the input size. Space complexity measures how much memory the algorithm uses.
- Big O notation: Used to express the scalability of an algorithm as its order. It represents the time complexity or performance of an algorithm, considering the worst-case scenario and assuming that every possible element is touched on during execution.
- Big O notation categories: O(1) for constant time, O(log n) for logarithmic time, O(n) for linear time, O(n^2) for polynomial time, and O(2^n) for exponential time.
- O(1) - Constant time: An algorithm that takes the same amount of time to execute regardless of the size of the input data set. Examples include len(list) for returning the length of a list and print(list[0]) for printing the first item of a list.","[Front: Admissible Heuristics Back: Sensible heurstic estimates calculated from additional data. e.g. Nodes represent towns, edges represent distances in km, Longitude and Latitude of each node to calculate straight line distance from any node to destination -  gives an admissible heuristic estimate. e.g. Nodes in a 2D maze, using OOP, each node can have its own set of coordinates and horizontal + vertical distance between nodes ignoring obstables can be used as heuristics. Or could calculate Pthag to find euclidean distance.],
[Front: Worked example of A* pathfinding algorithm Back: Starting with node A, set g = 0 and f = 34. Other g's of other nodes have been set to infinity. Start with A, consider each connected node, not yet visited: C and D. Considering C: calcuate shortest distance from start (g): A's distance from start to A-C edge value: 0 + 10, then f value : 10 + 22 =32, 32 < infinity so update table and set previous node to A.  Consider other node, D: D's g value is A's distance from start + A-D edge weight: 0 +4 = 4, F value = 4 + 27 = 31 < infinity so update table and set previous node to A. All of A's connected node's have been considered so A has now been visited.  Now consider next unvisited node with lowest f value: D. D's connected nodes: E, E's g is = D's distance from start + D-E edge weight: 4+1 = 5, E f value: 5 + 24 = 29 < inifinity so update E in table and set previos node to D. Now all of D's connected nodes have been considered, so set it to visited.  Now consider next unvisited node with lowest f value: E. E's connected nodes not visited: C,G,H,J. Calculate g and f values and update table if f value is lower. C: g = 5+4 = 9 f = 9+22 = 31 f value is lower so update table. G: g = 5+4 = 9 f = 9+27 = 36 f value is lower so update table. H: g = 5+6 = 11 f = 11+13 = 24 f value is lower so update table. J: g = 5+7 = 12 f = 12+16 = 28 f value is lower so update table. All of E's connected nodes have been considered so it has now been visited.  Now consider next unvisited node with lowest f value: H. Consider each unvisited node connected to H: I,M. I: g = 11 + 9 = 20, f = 20 + 9 = 29. f value is lower so update table. M: g = 11+6 = 17, g = 17+5=22. f value is lower so update table. All of H's connected nodes have been considered so now it is visited. Now consider next unvisited node with lowest f value: M. Consider each unvisited node connected to M: L. L:  g = 17+4=21, f = 21+0=21 f value is lower so update table. All of M's connected node have been considered so update table.  A route to L has been found: A → D → E → H → M → L, possible more optimal route from I to L. We need to follow the algorithm through until the goal node has been visited. Now consider next unvisited node with lowest f value: L.  Consider each unvisted node connected to L: I. I: g = 21+5=26, f=26+29 =55, higher than the currently stored f value (29) so don't update table. L has now been visited so set it to visited. Now found the goal node, considered all adjacent nodes. Once goal node is visited, there are no shorter paths to discover.  A → D → E → H → M → L],
[Front: A* pathfinding algorithm in steps Back: Set initial g and f value for all nodes in the graph. (0 or start node and infinity for all other nodes)While goal not visited:Find the node with lowest f value not yet visitedFor each connected node that has not been visted:Caculate distance from start by adding edge value and heuristicIf distance from start + heuristic < than current f value:Set f value of connected node to the newly calculated distance.Set the previous node to be current node.Set current node as visited.Start from goal node.Add the previous node to the start of the list.Repeat from step 3 until start node is reached.Output list. Steps 1 and 2 calculates the shortest path. Steps 3-6 outputs the shortest path.],
[Front: Ways to implement A* pathfinding algorithm Back: For worked examples in real life, can use a single table / array. Implementing as an array, wouldn't be able to mix string and integer data types easily without lots of unnecessary casting. Could use 2 lists or dictionariesOne for containing all unvisited nodesOne for containing all visited nodesAdd each node to a priority queue when its first discovered, once it has left it is then classed as visited.],
[Front: Measures of an algorithm's complexity Back: Time complexitySpace complexity Algorithms should aim to run as quick as possible and take up the least amout of space possible.],
[Front: Big O notation Back: Used to express the scalability of an algorithm as its order. Expresses the time complexity, or performace of an algorithm. Considers worst case scenario, assumes that every possible element is touched on as the algorithm executes.],
[Front: Big O notation categories Back: O(1) - Constant timeO(log n) Logarithmic timeO(n) - Linear timeO(n^2) - Polynomial timeO(2^n) - Exponential time],
[Front: O(1) - Constant time Back: An algorithm that takes the same amount of them to execute regardless of the size of the input data set.  e.g. len(list) will take the same amount of them to execute no matter the number of items in the list.]"
- O(log n) - Logarithmic time: An algorithm's time to complete grows very slowly as the dat,"[Front: O(log n) Logarithmic time Back: An algorithm's time take to complete will grow very slowly as data set size increases.  e.g. Binary search is log base 2 n, doubling size of data set has very little effect on the time the algorithm takes to complete.],
[Front: O(n) - Linear time Back: An algorithm with the time to complete it grows in direct proportion to the data set size.  Performance declines as data set grows. Reduces efficiency with increasingly large data sets. e.g. Linear search list of 1000 items will take 1000 times longer than searching a list of 1 item.],
[Front: O(n^2) - Polynomial time Back: An algorithm where performance is directly proportional to the square of the data set size.  Significantly reduces efficiency with increasingly large data sets.  e.g. nested loops, e.g. of 3 nests = n^3, 4 nests = n^4.],
[Front: O(2^n) - Exponential time Back: An algorithm where time taken to execute doubles with every item added to the data set. Execution time growns exponentially.],
[Front: O(1) - Constant time example Back: len(list), returning the length of the list in the same time regardless of the number of items in it. print(list[0]) printing the first item of a list, will take the same time regardless of the number of items in the list.]"
