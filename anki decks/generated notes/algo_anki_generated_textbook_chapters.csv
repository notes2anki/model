"Chapter Title: Linear Search

Chapter Summary:
In this chapter, we will explore linear search, a simple algorithm used to find an item in a list, regardless of whether the list is sorted or not. We will discuss the overview of linear search, its applications, and its efficiency for different data sets.

Section 1: Overview of Linear Search
- Definition of linear search
- Process of linear search
- Advantages and disadvantages of linear search
- Efficiency of linear search for smaller and larger data sets

Section 2: Applications of Linear Search
- Unordered data and settings file
- Find and replace function in a word processor
- Other examples of linear search in real-world scenarios

Section 3: Implementing Linear Search
- Pseudocode for linear search with explanations
- Step-by-step execution of the linear search algorithm
- Understanding the Boolean variable 'found' and the index variable

Section 4: Efficiency Analysis
- Time complexity of linear search
- Best-case, worst-case, and average-case scenarios
- Comparing linear search with other search algorithms","[Front: Linear Search overview Back: Finds an item in a(n) (un)sorted list. Starts at the first item and checks each item one by one. Doesn't required the data set to be in order Can be efficient for smaller data sets Inefficient for large data sets],
[Front: Applications of linear search Back: Ideal for finding items in small data sets and searching unoredered data such as a settings file. Typical use of linear search would be a find and replace function in a word processor Easiest search algorithm to implement but usually most inefficient.]"
"Chapter Title: Linear Search Pseudocode

Chapter Summary:
This chapter focuses on the pseudocode implementation of linear search. We will discuss the variables used, the while loop, and the step-by-step process of finding an item in a list. Additionally, we will provide a version of the pseudocode without comments for clarity.

Section 1: Understanding Linear Search Pseudocode
- Introduction to linear search pseudocode
- Variable initialization: 'found' and 'index'
- Conditions for entering the while loop

Section 2: Step-by-Step Execution of Linear Search
- Checking each item in the list
- Comparing the current item with the item to find
- Updating the 'found' and 'index' variables accordingly

Section 3: Linear Search Pseudocode without Comments
- Pseudocode without explanations for easier understanding
- Comparison with the commented version","[Front: Linear search psuedocode Back: found  = False index = 0  # start by initialising variables with their starting state. # ""found"" Boolean value is used to indicate whether the item we are searching fro has been found or not - start with False. # ""index"" specifies current position in the data set, starting at 0, we will assume the data being searched is stored in array or list. While found == False and index < items.Length #We enter a While loop that will continue to execute while found is False and index is less than the lengh of the items list.            If items[index] == itemToFind then #Each time around the loop, the program checks to see if the current item is the one we are searching for.                found = True #if it is, then Found is set to true causing the exit of the loop at the start of next iteration            Else                index = index + 1 #if it isn't then increment index by 1, meaning next iteration of the loop, the program will be checking against the next location the data set.            End IF  End While],
[Front: Linear search psuedocode without comments Back: found = False index = 0   While found == False and index < items.Length            If items[index] ==  itemToFind then                found = True            Else                index = index + 1            End If End While]"
"Chapter Title: Essential Components of Linear Search

Chapter Summary:
In this chapter, we will explore the essential components of the linear search algorithm. We will discuss the goals it must achieve, regardless of the data set's order or existence of the item being searched. Additionally, we will cover the importance of sequentially checking each item.

Section 1: Goals of Linear Search Algorithm
- Locating an item in a data set if it exists
- Handling both sorted and unsorted data sets
- Graceful execution even if the item doesn't exist
- Sequentially checking each item in the data set

Section 2: Handling Sorted and Unsorted Data Sets
- Exploring the efficiency of linear search regardless of the data set's order
- Advantages and disadvantages of linear search for sorted and unsorted data

Section 3: Sequential Item Checking
- Importance of checking each item in order
- Implications of not sequentially checking items

Section 4: Practical Considerations
- Optimizing linear search for specific scenarios
- Limitations and alternatives to linear search

Please note that these textbook chapters are generated based on the provided flashcards. Adding more details or rearranging the sections can be done upon request",[Front: Linear search algorithm must: Back: Be able to locate an item in a data set if it exists Be able to locate the item regardless of whether the data set is sorted or not. Run without crashing even if the item being searched for doesn't eexist in the data set. Check each item sequentially starting with the first item.]
"Chapter 1: Linear Search and Binary Search
1.1 Limitations of Coded Linear Search
- Explains that the linear search algorithm exits as soon as the first occurrence of the item is found
- Discusses the limitation of being unable to find the first, last, or all occurrences

1.2 Binary Search Overview
- Provides an efficient algorithm for finding an item in a sorted data set
- Explains the process of starting at the middle of the list and repeatedly dividing the list in half
- Highlights the requirement of the data set to be sorted first
- Emphasizes the efficiency of binary search for large data sets

1.3 Applications of Binary Search
- Discusses the ideal scenarios for using binary search, such as searching for an item in a large sorted data set
- Illustrates the quick reduction of large data sets to manageable sizes by discarding half of the data after each iteration

1.4 Pseudocode for Binary Search
- Presents the pseudocode for implementing binary search, including explanations of each step
- Covers the initialization, loop conditions, midpoint calculation, item comparison, and adjustments of the first and last indices

1.5 Pseudocode for Binary Search (Without Comments)
- Provides a concise version of the pseudocode for binary search without the comments","[Front: Limitations of coded linear search: Back: Version exits as soon as the first occurence of the item is found What if you wanted to find the first, last or all occurences?],
[Front: Binary search overview Back: Efficient algorithm for finding an item in a sorted data set. More efficient than linear search. Starts at the middle of the list and repeatedly divides the list in half Requires the data set to be sorted first e.g. numerical or alphabetical order Efficient for large data sets],
[Front: Applications of binary search Back: Ideal when you need to search for an item in a large sorted data set e.g.  online dictionary where words are sorted in alphabetical orderAs it discards half of the data after each iteration, it quickly reduces the very large data sets containing millions of records to one much more manageable.],
[Front: Psuedocode binary search Back: found = False first  =  0 last = items.length - 1 #found is used to indicate whether the item we are searching for has been found or not- seting it to false #first/last: with each iteration, we need to know the curretn index of the first and last item in data set so we can find the mid point. MP changes with each iteration. To start with, we will be searching the entire data set, so set ""first"" to index 0 and ""last"" to length of data set - 1 which will be the index of the last item.  While first <= last and found == False #Enter a while loop that continue to iterate providing both first <= last and found == False. Loop will iterate until item is found or entire data set has been searched.       midpoint = (first + last) DIV 2 #Calculate the MP of data set. Add index values in ""first"" and ""last"" and do floor division to get an integer.       IF items[midpoint] == itemToFind then #Each iteration, program checks if the item at the MP of the data set is the one we are searching for.           found = True #if it is, ""found"" is set to True and loop will exit at the start of the nnext iteration       Else           If items[midpoint] < itemToFind then #if not then program will check if the MP is less than or greater than the desired item, allowing us to discard half the entire data set. We can do this becuase items in the data set of a binary search are stored in order.              first = midpoint + 1 #if item at MP is less than the desired value, we adjust ""first"" to point at the index value in MP + 1           Else               last = midpoint = 1 #if item at MP is more than the desired value, we adjust ""last"" to point at the index value in MP - 1 #Repeat while loop until we find desired item or prove that item is not in data set.           End If        End If End While],
[Front: Binary seach psuedocode without comments Back: found = False first = 0 last = items.Length -1  WHILE first <= last and found == False         midpoint = (first+last) DIV 2         IF items[midpoint] == itemToFind then             Found = True         Else           IF items[midpoint] < itemToFind then               first = midpoint + 1           Else                last = midpoint - 1           End IF         End If End While]"
"Chapter 2: Bubble Sort
2.1 Bubble Sort Overview
- Introduces bubble sort as a sorting algorithm for unordered lists
- Describes the process of comparing each item with the next one and swapping them if necessary
- Explains that the algorithm finishes when no more swaps can be made and the largest (or smallest) elements bubble up to the end of the list

2.2 Applications of Bubble Sort
- Discusses the inefficiency of bubble sort compared to other sorting algorithms
- Mentions that it is easy to implement and suitable for very small data sets
- Highlights situations where a simple and easy-to-program sorting algorithm is required

2.3 Pseudocode for Bubble Sort
- Presents the pseudocode for implementing bubble sort, including explanations of each step
- Covers the loop conditions, swapping of items, and iteration through the data set

2.4 Pseudocode for Bubble Sort (Without Comments)
- Provides a concise version of the pseudocode for bubble sort without the comments

Chapter 3: Insertion Sort
3.1 Insertion Sort Overview
- Introduces insertion sort as a way to insert each item into its correct position in a data set
- Mentions its usefulness for small data sets and particular efficiency when inserting items into a pre-sorted list
- Notes the inefficiency for larger data sets

3.2 Pseudocode for Insertion Sort
- Presents the pseudocode for implementing insertion sort, including explanations of each step
- Covers the iteration through the data set, comparisons of items, and the process of moving items within the data structure

3.3 Pseudocode for Insertion Sort (Without Comments)
- Provides a concise version of the pseudocode for insertion sort without the comments

3.4 Inefficiencies of Insertion Sort
- Discusses the main inefficiency of insertion sort: the need to move all items in the data structure when inserting","[Front: Bubble sort overview: Back: Sorts an unordered list of items by comparing each item with the  next one and swapping the items if it is greater than it. Algorithm is finished when no more swaps can be made. It bubbles the largest or smallest up to the end of the list. Last element will be in correct place after first pass.],
[Front: Applications of bubble sort Back: Most inefficient sorting algorithm Easy to implement Popular choice for very small data sets Ideal for situations where a simple easy to program sorting  algorithm is required.],
[Front: Bubble sort psuedocode Back: n = items.length swapped  = True # ""n"" used to track how far through the data set we need to check for items to swap on each iteration. start by setting it to then length of the data set.  #""swapped"" used to indicate whether a swap has taken place each iteration of the inner for loop. start by setting it to true so we will enter the main WHILE loop at least once to check for unsorted items. WHILE n > 0 AND swapped == True #enter a while loop which will iterate while n>0 and swapped == True. Loop will iterate until all items are sorted           swapped = False #each iteration the while loop assumes there are no items that need to be swapped until we prove otherwisw, so we set ""swapped"" to false.           n = n -1 #ensures that the length of the list is inline with 0 indexing. Ensures that the entire data set will be checked the first iterations for items to swap. This value will decrement by 1 each iteration of the outer WHILE loop. Sorted items will gradually, bubble up to the end of the data set so there will be fewer items to check through each iteration.           For index = 0 To n-1 #nested inner for loop. for each pass through the data set, respresented by the while loop, we need to start through the beginning and work through to the penultimate item of the unsorted data set, represented by n - 1. Need to work through the current subset of items that still need to be check.                If items[index] > items[index+1] then #if we find that the item at the current location in the data set is greater than the next item, we know it is out of order                    Swap(items[index] , items [index+1])                    swapped = True #we then swap the 2 items, then set ""swapped"" to true so that when we next check the outer while loop, we know we are still in the process of sorting the data out.                  End IF            End For #continue through the data set moving the item up as far as it needs to go until it is in the correct place. End WHILE #process is repeated as many times necessary until we discover the entire data set has been sorted.],
[Front: bubble sort pseudocode without comments Back: n = items.Length swapped = True  While n > 0 AND swapped == True           swapped = False           n = n -1           For index = 0 TO n-1                  If items[index] > items[index+1] then                     Swap(items[index] , items[index+1])                     swapped = True                 End if           End For End While],
[Front: Insertion sort overview: Back: Inserts each item into its correct position in a data set one at a  time. Useful for small data sets. Partically useful for inserting items into a ready sorted list Inefficient for larger data sets.],
[Front: Insertion sort psuedocode Back: For index = 1 TO items.Length: #algorithm sets a for loop to iterate through the data set #it compares the item in items[1] with item immediately before it, at items[0]. This is why the for loop starts at 1 not 0, if we started at 0, we would be trying to compare the very first item in the data set with one at position items [-1] which would cause an out of bounds error.        current = items[index] #first thing we do each iteration is take a copy of item we are sorting and place it in temporary ""current"". We do this because if we  find items before it are wrong order, we will need to move them  up in the data set. In doing this we would override the original  term and we need a way of getting back to insert it into its current location.        index2 = index #set index2 to be same value as index 1. index2 used to track where we need to exit inner While loop. Every iteration of outer FOR loop, we need to check the current item against items before it. As we iterate through the data set, this number increases.          While index2 > 0 AND items[index2-1] > current #inner while loop is executed if any additional items before the one one we are comparing that still needs to be checked with index2 > 0 AND we check if that the item is greater than the one we are comparing, if it is, then we know the items are out of place.                items[index2] = items[index2 - 1]                index2 = index2 - 1 #Here we move the item up by 1 space and decrement index2 by 1. Then we check again to see if the item is in the correct place. If still not in the correct place, we repeat the while loop, moving all the items before the one we are comparing up one place till we discover the correct location.        End While #drop out of the while loop.          items[index2] = current #take a copy of the item we are comparing held in current, place the copy in its correct location. #outer for loop now increments and the whole process repeats. This time we are trying to locate the correct position of the next item.  End for],
[Front: insertion sort pseudocode without comments Back: For index = 1 TO items.Length :       current = items[index]        index2 = index         While index2 > 0 AND items[index2 - 1] > current              items[index2] = items[index2 -1]              index2 = index2 - 1        End While           items[index2] = current End For],
[Front: Inefficienies of insertion sort Back: Having to move all the items in the data structure so we can insert the ""current"" item into its new location - only to find that we need to repeat the process again and again. Gets worse with larger data sets and if data is poorly sorted already when inserting.  Could have used a linked list which would negate the need to move items within the data structure. Instead we would need to update various pointers linking nodes together to reflect new structure  each iteration.],
[Front: Stacks Back: Items are pushed onto the top of the stack when added Popped off the top when deleting Peek  = look at top without deleting Last in First out Structure Last pushed on must be first popped off stack pointer always points to the node on the top any attempt to push an item onto a full stack is called a stack  overflow any attempt to pop an item of an empty stack is called stack  undeflow Often implemented using an array can also be created using OOP.],
[Front: Queue Back: Linear data structure Enqueued at the back Dequeued from the from can peek at the fron without deleting it priority queue -  certain items can join the front of the queue First in First out structure back/tail pointer always points to the last item in the queue front/head pointer - points to the first attempts to enqueue items to a full queue is queue overflow dequeue an empty queue is queue underflow Can be implemented using an array or OOP.]"
":

Chapter 1: Linear Search and Binary Search
1.1 Limitations of Coded Linear Search
- Explains that the linear search algorithm exits as soon as the first occurrence of the item is found
- Discusses the limitation of being unable to find the first, last, or all occurrences

1.2 Binary Search Overview
- Provides an efficient algorithm for finding an item in a sorted data set
- Explains the process of starting at the middle of the list and repeatedly dividing the list in half
- Highlights the requirement of the data set to be sorted first
- Emphasizes the efficiency of binary search for large data sets

1.3 Applications of Binary Search
- Discusses the ideal scenarios for using binary search, such as searching for an item in a large sorted data set
- Illustrates the quick reduction of large data sets to manageable sizes by discarding half of the data after each iteration

1.4 Pseudocode for Binary Search
- Presents the pseudocode for implementing binary search, including explanations of each step
- Covers the initialization, loop conditions, midpoint calculation, item comparison, and adjustments of the first and last indices

1.5 Pseudocode for Binary Search (Without Comments)
- Provides a concise version of the pseudocode for binary search without the comments

Set 2:

Chapter 2: Bubble Sort
2.1 Bubble Sort Overview
- Introduces bubble sort as a sorting algorithm for unordered lists
- Describes the process of comparing each item with the next one and swapping them if necessary
- Explains that the algorithm finishes when no more swaps can be made and the largest (or smallest) elements bubble up to the end of the list

2.2 Applications of Bubble Sort
- Discusses the inefficiency of bubble sort compared to other sorting algorithms
- Mentions that it is easy to implement and suitable for very small data sets
- Highlights situations where a simple and easy-to-program sorting algorithm is required

2.3 Pseudocode for Bubble Sort
- Presents the pseudocode for implementing bubble sort, including explanations of each step
- Covers the loop conditions, swapping of items, and iteration through the data set

2.4 Pseudocode for Bubble Sort (Without Comments)
- Provides a concise version of the pseudocode for bubble sort without the comments

Chapter 3: Insertion Sort
3.1 Insertion Sort Overview
- Introduces insertion sort as a way to insert each item into its correct position in a data set
- Mentions its usefulness for small data sets and particular efficiency when inserting items into a pre-sorted list
- Notes the inefficiency for larger data sets

3.2 Pseudocode for Insertion Sort
- Presents the pseudocode for implementing insertion sort, including explanations of each step
- Covers the iteration through the data set, comparisons of items, and the process of moving items within the data structure

3.3 Pseudocode for Insertion Sort (Without Comments)
- Provides a concise version of the pseudocode for insertion sort without the comments

3.4 Inefficiencies of Insertion Sort
- Discusses the main inefficiency of insertion sort: the need to move all items in the data structure when inserting","[Front: Implementation of pushing onto a stack using a static array Back: 1. check the stack and output and error if its ful 2. increment the stack pointer insert the new data item at the location pointed to by the stack  pointer  function isFull(top)     if top == maxSize - 1 then           return true     else          return false     end if end function  procedure push(stack, top, data)          if isFull(top) == True then             print(""stack is full"")          else              top = top + 1              stack[top] = data           end if           return top end procedure],
[Front: Implementation of pushing onto a stack using OOP and a linked list Back: class Node        private data        private next         public proecdure new(newItem)           data  = newItem           next = Null        end procedure         public function getData()           return data        end procedure              public function getNext()           return next        end procedure         public procedure setNext(newNext)              next = newNext        endprocedure  public procedure push (data)          newNode = Node(data)           if top != Null then               newNode.setNext(top)           end if           top = newNode end proecedure  end class  class Stack        private top         public procedure new()                  top = Null        end procedure  end class],
[Front: Measurements of algorithm efficiency Back: Time complexity - how much time they need to solve a problem Space complexity - Amound of resources they require],
[Front: Comparing linear and binary search on a large data set. Back: Linear Binary                 Items do not need to be stored in order Items must be in order for the algorithm to work Start at the first item start at the middle item Search each item in sequence until each item is found or there are no items to  check halves the set of items to search after each comparison until the item is found or there are no more items to check - Divide and Conquer reduces data set by half each iteration. Can be implemented using an array or linked list Can be implemented using an array or binary tree new items are added at the end - quick New items must be added in the correct place to maintain the order of items - can be slow suitable for small number of items Suitable for a large number of items],
[Front: Merge Sort overview Back: Can sort a data set extremely quickly using divide and conquerPrinciple of divide and conquer is to create 2 or more identical subproblems from the larger problem, solve them individually and combine their solutions to solve the overaching problem.Divide the unsorted list into n sublists, each containing one element.Repeatedly merge sublists, to produce new sorted sublists until there is only sublist remaining, being the sortest list.],
[Front: Applications of merge sort Back: Suitable fot any data sets but works best with large ones where memory is not a concern However, the time take to perform the sort should be minimised. Ideal for parallel processing environments where the concept of divide and conquer can be used.],
[Front: Merge sort steps Back: Repeatedly divide the list in half until each item is in its own list Take 2 adjacent lists and start with the first item in each one Compare the 2 items Insert the lowest items into a new list. Move to the next item in the list it was taken from Repeat steps 3 and 4 until all the items from one of the lists are in the new list Append all the items from the list that still contains items to the new list Replace 2 adjacent lists with the new listRepeated from step 2 until all adjacent lists have been compared Repeat from step 2 until only one list remains Steps 3 to 6 take place inside the merge function],
[Front: Merge sort psuedocode step 1: Repeatedly divide the list in half until each item is its own list. Back: #main algorithm starts here items = [""Florida"" ,""Georgia"",""Delaware"",""Alabama""] listOfItems = [] item = [] #every item is put into its own list with a containter list  for n = 0 TO items.length - 1       item = items[n]       listOfItems.append(item)  #listOfItems contains a set of lists that all contain a single item],
[Front: Merge sort psuedocode step 2: Take 2 adjacent lists and start with the first item in each one Back: #Repeat while there is more than one list While listOfItems.Length != 1           index = 0           #Merge pairs of lists           While index < listofItems.Length - 1               newList = merge(listOfItems[index], listOfItems[index+1])  #function to merge 2 lists into a new list Function merge(list1, list2)          newList = []          index1 = 0          index2 = 0]"
"Chapter Title: Sorting Algorithms - Merge Sort

Chapter Introduction:
In this chapter, we will explore one of the most efficient sorting algorithms called Merge Sort. Merge Sort is a divide-and-conquer algorithm that recursively divides the input list into smaller sublists until each sublist contains only one element. Then, it merges these sublists back together in a sorted order, producing a fully sorted list. We will dive into the pseudocode and step-by-step process of Merge Sort.

Section 1: Merge Sort Pseudocode
In this section, we will present the pseudocode for Merge Sort, which outlines the key steps involved in the algorithm. We will explain each step in detail and provide a line-by-line explanation of the code. The pseudocode includes steps such as comparing and merging items from two lists, repeating the process until one list is empty, and appending the remaining items.

Section 2: Merge Sort Step-by-Step
Here, we will walk through the step-by-step process of Merge Sort using a graphical representation. We will demonstrate how the algorithm splits the input list into sublists, compares and merges the sublists, and produces a sorted list. This visual representation will help in understanding the inner workings of Merge Sort.

Section 3: Implementation and Performance Analysis
In this section, we will discuss the implementation considerations of Merge Sort, such as choosing appropriate data structures and handling edge cases. Additionally, we will analyze the performance of Merge Sort in terms of time and space complexity. We will compare its efficiency with other sorting algorithms and highlight its advantages.

Chapter Summary:
In this chapter, we explored the Merge Sort algorithm, which is widely used for sorting large data sets. We discussed the pseudocode, step-by-step process, and implementation considerations of Merge Sort. Through this chapter, you have gained a comprehensive understanding of how Merge Sort works and its significance in sorting algorithms.","[Front: Merge sort psuedocode step 3: Compare the 2 items and step 4: insert the lowest item into a new list, move from the next item in the list it was take from. Step 5: Repeat steps 3 and 4 until all the itmes from one of the lsits are in the new list. Back: #Check each item in each list, and add the smallest item to a new list  While index1 < list.Length and index2 < list2.Length          If list1[index1] > list2[index2] Then             newList.append( list2[index2])             index2 = index2 + 1          Else if list1[index1] < list2[index2] Then             newList.append(list1[index1])             index1 = index1 + 1           Else if list1[index1] == list2[index2] Then             newList.append( list2[index2])             index2 = index2 + 1             newList.append(list1[index1])             index1 = index1 + 1           End if End While #the process needs to be repeated until all the items from one of the lists have been put into the ""newList""],
[Front: Merge sort step 6: Append all of the items from the list that still contains items to the newList Back: #add left over items from the remaining list If index1 < list.Length Then     For item = index1 to list1.Length            newList.append(list1[item])     Next item Else if index2 < list2.Length Then     For item = index2 to list2.Length           newList.append (list2[item)     Next Item End if Return newList  #main program newList = merge(listOfItems[index], listOfItems[index+1]],
[Front: merge sort Step 7: replace 2 adjacent lists with the new list step 8: repeat from step 2 until all adjacent lists have been compared. 9: Repeat from step 2 until only one list remains. Back: #repeat while there is more than one list While listOfItems.Length != 1        index = 0        #Merge pairs of lists        While index < 1 list of items.Length - 1                 newList = merge(listOfItems[index], listofItems[index+1])                 listofItems[index] = newList                 #once merged, delete one of the now redunant lists                 del listOfItems[index+1]                  index = index + 1         End while End while],
[Front: Linear search psuedocode from textbook Back: ],
[Front: Applications of insertion sort Back: Useful for small data sets Particularly useful for insterting items into a ready sorted list.]"
"Chapter Title: Sorting Algorithms - Quick Sort

Chapter Introduction:
In this chapter, we will delve into another efficient sorting algorithm called Quick Sort. Quick Sort is also a divide-and-conquer algorithm, but it uses a different approach than Merge Sort. It selects a pivot value from the input list and splits the list into two sublists: one with values smaller than the pivot and another with values greater than the pivot. We will explore the pseudocode, steps, and applications of Quick Sort.

Section 1: Quick Sort Overview
This section provides an overview of Quick Sort, explaining its key features and advantages. We will discuss how Quick Sort partitions the input list, uses a pivot value for comparisons, and recursively sorts the sublists until the entire list is sorted. Additionally, we will highlight the memory efficiency of Quick Sort compared to Merge Sort.

Section 2: Quick Sort Steps
Here, we present a detailed explanation of the steps involved in the Quick Sort algorithm. We will cover essential aspects such as selecting a pivot value, partitioning the list based on the pivot, and recursively applying Quick Sort to the divided sublists. Through this section, you will gain a comprehensive understanding of the step-by-step process of Quick Sort.

Section 3: Applications of Quick Sort
In this section, we will explore various real-world applications where Quick Sort finds its usefulness. Quick Sort's efficiency and ability to handle large data sets make it suitable for applications such as medical monitoring, life support systems, aircraft controls, and defense systems. We will delve into these applications, discussing the specific scenarios where Quick Sort excels.

Chapter Summary:
In this chapter, we explored the Quick Sort algorithm, which offers fast and efficient sorting capabilities. We discussed the overview, steps, and applications of Quick Sort, providing you with a solid foundation in understanding this algorithm. The chapter concludes with an appreciation of Quick Sort's strengths and its relevance in numerous practical scenarios.","[Front: Merge sort process graphically Back: ],
[Front: Merge sort textbook psuedocode Back: ],
[Front: Quick sort overview Back: Orders a data set extremely quickly using divide and conquer Uses a pivot value from the data set which other items are compared against to determine their position. Typically requires less memory than merge sort.],
[Front: Applications of quick sort Back: Suitable for any data set but more for larger data sets. Ideal for parallel processing environments where divide and conquer can be used. Used in: Medical monitoringLife support systemsAircraft controlsDefence systems],
[Front: Quick sort steps Back: Select a value to be pivot value. Used to compare values. Final position of pivot value is called split point which is used to divide the list for subsequent calls. Select a leftmark and right mark, beginning and end of remaining items in list. If the leftmark is less than pivot value, move leftmark pointer to the right till you find a leftmark value greater than pivot.If the rightmark pointer is greater than pivot value, move rightmark pointer to left till you find a rightmark value less than pivot.Exchange leftmark and rightmark values.Continue with leftmark rightmark moving process.Once leftmark and right mark have crossed, stop moving process.Swap pivot value for the place stopped (split point).LHS of split point is less and RHS is greater, list can be divided at split point and quick sort invoked recursively on 2 halves.]"
"Chapter Title: Graph Algorithms - Djikstra's Shortest Path

Chapter Introduction:
In this chapter, we will delve into the Djikstra's Shortest Path algorithm, which is widely used in graph theory to find the shortest path between two nodes in a weighted graph. We will provide an overview of the algorithm, explain its steps, and discuss its applications. Djikstra's algorithm employs a breadth-first search approach and utilizes a priority queue to determine the shortest paths.

Section 1: Djikstra's Shortest Path Overview
In this section, we will introduce Djikstra's Shortest Path algorithm and its primary goal of finding the shortest path between a start node and all other nodes in a weighted graph. We will provide an overview of the algorithm and discuss its fundamental characteristics, including its reliance on breadth-first search and the concept of temporary distances.

Section 2: Djikstra's Shortest Path Steps
Here, we will explore the step-by-step process of Djikstra's Shortest Path algorithm. We will outline the key steps involved in calculating the shortest paths, such as setting temporary distances, visiting unvisited nodes, calculating distances from the start, updating distances if a shorter path is found, and maintaining a previous node reference. By understanding these steps, you will gain a clear comprehension of how Djikstra's algorithm operates.

Section 3: Djikstra's Shortest Path Applications and Implementations
In this section, we will discuss the practical applications of Djikstra's Shortest Path algorithm. Specifically, we will explore its implementation in various fields, such as GPS navigation, IP routing, and telephone networking. Additionally, we will discuss the different ways to implement Djikstra's algorithm, including using tables or arrays, queues, and lists.

Chapter Summary:
This chapter provided a comprehensive exploration of Djikstra's Shortest Path algorithm, a fundamental graph algorithm used in various real-world applications. We covered its overview, step-by-step process, and implementation considerations. By grasping the concepts presented in this chapter, you will possess a solid understanding of Djikstra's algorithm and its significance in graph theory","[Front: Quick sort psuedocode Back: ],
[Front: Advantages of quick sort Back: Extremely fast. If partition always occurs in middle of the list there will be log n divisions in a list of length n, and each of the n items need to be checked against pivot value to find split point. O(n log n). Doesn't need additional memory.],
[Front: Disadvantages of quick sort Back: If split points are not near the middle of the list, but close to start or end, division will be uneven. If split point is first item in a list, division results in a list of 0 items and a list of n-1 items. List of n-1 items divides into 0 items and n-2 items and so on. Resulting in time complexity O(n^2) If list is large and recursion takes too long, may cause stack overflow and program will crash.],
[Front: Djikstra's shortest path algorithm overview Back: Find's the shortest path between one start node and all other nodes on a weighted graph. A type of breadth first search.],
[Front: Disadvantage to Djikstra's shortest path algorithm Back: Doesn't work for edges with a negative weight value.],
[Front: Difference between Djikstra's and A* Back: A* uses heuristics while Djikstra's does not.],
[Front: Applications of Djikstra's Back: Used for purpose to find the shortest path between 2 points e.g.: GPS navigationIP routingTelephone networking],
[Front: Ways to implement Djikstra's Back: Using a table or array Queues and a series of lists],
[Front: Djikstra's shortest path steps Back: Set temporary distances from start value for all nodes. 0 for start node and infinity for others.For each node in the graph:Find the node with the shortest distance from the start that hasn't been visited.For each connected node that hasn't been visited:calculate distance from startIf the distance from the start is lower than the currently recorded distance from the start:Set the shortest distance to the start of the connected node to the newly calculated distance.Set previous node to be current nodeMark the node as visited.Start from goal node.Add previous node to start of the listRepeat from step 5 until start node reachedOutput list 1 - 3 calculates shortest path 4 - 7 outputs the shortest path from start node to goal node],
[Front: Worked example of Djikstra's using table Back: Find the node with shortest distance from start that hasn't been visited. Which is node A, has a distance of 0 from start node.  Now consider each connected node, not yet visited. B,C,D.  First consider B, calculate distance from start, so A's distance from start + the A to B edge weight: 0 +4 = 4.  Check if B's calculated distance from start is lower than current recorded distance from start: 4 < infinity so update B's distance from start to new distance and set previous node column to be the current node, A.  Now consider C and D. C: 0 +3 = 3. D: 0 + 2 = 2. Both < infinity so update C and D distnace and set previous node to A.  All A's connected nodes have been considered so A can be marked as visited.  Next consider the node with the shortest distance from start that hasn't been visited: D. Consider each node connected to D that hasn't been visited: C and F.  Calculate each nodes distance to start so D's distance from start + B to node's edge weight. C: 2 +1 = 3. This is not less than recorded distance from the start so no update required. F: 2+2 = 4. 4 < inifinity, so update F distance from start. All D connected nodes considered so marked as visited.   Next consider the node with the shortest distance from start that hasn't been visited: C. Consider each node connected to C that hasn't been visited yet. Both A and D have been visited already so, C can be marked as visited.  Next consider the node with the shortest distance from start that hasn't been visited: B or F. Consider B: Consider each node connected to B not visited yet: E. E distance from start: 4 + 4 = 8. 8 < infinity so update E distance from start. Update the previous node we've come from, B. B has had all of its connected nodes considered so mark as visited.  Node with shortest distance from start not yet visited: F. Consider each node connected to F not visited: G. G's distance from start : F's distance from start + F to G edge weight : 4 + 5 = 9. 9 < infinity so update G in table.  Done with F so it is marked as visited.   Node with shortest distance from start not visited: E. Each node connected to E not yet visited: G. G's distance from start: E's distance from start + E to G edge weight: 8 +2 = 10. 10 > 9 so not updated. Finished with E so mark it a visited.  Node with shortest distance from start not yet visited: G. Consider each node conncted to G not yet visited. None so G is marked as visited.  Outputting shortest path: Start with goal node and follow previous node back to start, inserting new node at front of the list. A to G: A → D → F → G.]"
"Djikstra's Algorithm and A* Pathfinding

Chapter 1: Djikstra's Algorithm
1.1 Introduction to Graphs
- Definition of graphs
- Nodes, edges, and weighted edges
- Directed and undirected graphs
- Path and shortest path

1.2 Djikstra's Algorithm Overview
- Introduction to Djikstra's algorithm
- Purpose and key concepts
- Step-by-step process
- Example of Djikstra's algorithm execution

1.3 Implementation using a Queue
- Assigning temporary distance values to nodes
- Adding edges to a priority queue
- Removing and processing nodes from the queue
- Updating distances and positions in the queue
- Completing the algorithm using a while loop

Chapter 2: A* Pathfinding Algorithm
2.1 Introduction to A* Pathfinding
- Overview of optimal pathfinding on weighted graphs
- Introduction to A* algorithm
- Comparison with Djikstra's algorithm

2.2 Heuristics in A* Pathfinding
- Definition and purpose of heuristics
- Admissible and inadmissible heuristics
- Real-life examples of admissible heuristics

2.3 A* Algorithm Steps
- Setting initial g and f values for nodes
- Iteratively finding the node with the lowest f value
- Calculating distances from start and updating f values
- Marking nodes as visited and updating the previous node
- Reaching the goal node and finding the shortest path","[Front: Djikstra's algorithm implemented using a queue Back: Assign a temporary distance value to each node, 0 for starting node and infinity for other nodesAdd all edges to a priority queue, sorted by current distance (putting starting node at the from, rest in random order)While queue is not empty:Remove the node ,u, from front of queueFor each unvisited neighbour, w, of the current node u:newDistance = distanceAtU + distanceFromUtoWif newDistance < distanceAtW thendistanceAtW = newDistancechange position of w in priority queue to reflect new distance to wendifnext wend while]"
"Applications and Complexity Analysis

Chapter 3: Applications of A* Pathfinding
3.1 Video Games
- Intelligent movement of non-player characters (NPCs)
- Real-time pathfinding in game environments

3.2 Network Packet Routing
- Efficient routing of network packets through various paths
- Minimizing latency and maximizing network performance

3.3 Financial Modeling
- Asset and goods trading optimization
- Finding optimal paths within financial models

3.4 Puzzle Solving
- Word ladders and similar puzzles
- Finding the shortest transformation between words

3.5 Social Networking Analysis
- Calculating degrees of separation between individuals
- Suggesting potential connections or friends

Chapter 4: Complexity Analysis and Big O Notation
4.1 Measures of Algorithm Complexity
- Time complexity and space complexity
- Importance of efficient algorithms

4.2 Big O Notation
- Purpose and significance of Big O notation
- Categories of Big O notation (constant, logarithmic, linear, polynomial, exponential)

4.3 Examples of Big O Notation
- Exploring each category with practical algorithm examples
- Understanding the scalability of algorithms in different scenarios

4.4 Choosing the Right Algorithm
- Considering complexity analysis in algorithm selection
- Balancing performance and efficiency trade-offs","[Front: A* pathfinding algorithm overview Back: Findes the shortest path between 2 nodes on a weighted graph using heuristics. Best first search algorithm, performs better than Djikstra's algorithm because not every node is considered, instead only most optimal path is followed to the goal. A heuristic estimates the cost of the path between the next node and the goal and follows the path. Has 2 cost function - g(x) real cost from source to a given node. h(x) - approx cost from node x to goal node, heuristic funciton, adequete solution not always optimum. Hueristic funciton should never overstimate the cost, real cost should always be > or = to h(x). total cost of each node is calcuated as f(x) = g(x) + h(x)],
[Front: Applications of A* pathfinding algorithm Back: Used in video games - moving NPCs appearing to move intelligentlyNetwork packet routingFinancial modelling for trading assets and goodsSolving puzzles like word laddersSocial networking analysis - calculating degrees of seperation between individuals to suggest friends],
[Front: Admissible Heuristics Back: Sensible heurstic estimates calculated from additional data. e.g. Nodes represent towns, edges represent distances in km, Longitude and Latitude of each node to calculate straight line distance from any node to destination -  gives an admissible heuristic estimate. e.g. Nodes in a 2D maze, using OOP, each node can have its own set of coordinates and horizontal + vertical distance between nodes ignoring obstables can be used as heuristics. Or could calculate Pthag to find euclidean distance.],
[Front: Worked example of A* pathfinding algorithm Back: Starting with node A, set g = 0 and f = 34. Other g's of other nodes have been set to infinity. Start with A, consider each connected node, not yet visited: C and D. Considering C: calcuate shortest distance from start (g): A's distance from start to A-C edge value: 0 + 10, then f value : 10 + 22 =32, 32 < infinity so update table and set previous node to A.  Consider other node, D: D's g value is A's distance from start + A-D edge weight: 0 +4 = 4, F value = 4 + 27 = 31 < infinity so update table and set previous node to A. All of A's connected node's have been considered so A has now been visited.  Now consider next unvisited node with lowest f value: D. D's connected nodes: E, E's g is = D's distance from start + D-E edge weight: 4+1 = 5, E f value: 5 + 24 = 29 < inifinity so update E in table and set previos node to D. Now all of D's connected nodes have been considered, so set it to visited.  Now consider next unvisited node with lowest f value: E. E's connected nodes not visited: C,G,H,J. Calculate g and f values and update table if f value is lower. C: g = 5+4 = 9 f = 9+22 = 31 f value is lower so update table. G: g = 5+4 = 9 f = 9+27 = 36 f value is lower so update table. H: g = 5+6 = 11 f = 11+13 = 24 f value is lower so update table. J: g = 5+7 = 12 f = 12+16 = 28 f value is lower so update table. All of E's connected nodes have been considered so it has now been visited.  Now consider next unvisited node with lowest f value: H. Consider each unvisited node connected to H: I,M. I: g = 11 + 9 = 20, f = 20 + 9 = 29. f value is lower so update table. M: g = 11+6 = 17, g = 17+5=22. f value is lower so update table. All of H's connected nodes have been considered so now it is visited. Now consider next unvisited node with lowest f value: M. Consider each unvisited node connected to M: L. L:  g = 17+4=21, f = 21+0=21 f value is lower so update table. All of M's connected node have been considered so update table.  A route to L has been found: A → D → E → H → M → L, possible more optimal route from I to L. We need to follow the algorithm through until the goal node has been visited. Now consider next unvisited node with lowest f value: L.  Consider each unvisted node connected to L: I. I: g = 21+5=26, f=26+29 =55, higher than the currently stored f value (29) so don't update table. L has now been visited so set it to visited. Now found the goal node, considered all adjacent nodes. Once goal node is visited, there are no shorter paths to discover.  A → D → E → H → M → L],
[Front: A* pathfinding algorithm in steps Back: Set initial g and f value for all nodes in the graph. (0 or start node and infinity for all other nodes)While goal not visited:Find the node with lowest f value not yet visitedFor each connected node that has not been visted:Caculate distance from start by adding edge value and heuristicIf distance from start + heuristic < than current f value:Set f value of connected node to the newly calculated distance.Set the previous node to be current node.Set current node as visited.Start from goal node.Add the previous node to the start of the list.Repeat from step 3 until start node is reached.Output list. Steps 1 and 2 calculates the shortest path. Steps 3-6 outputs the shortest path.],
[Front: Ways to implement A* pathfinding algorithm Back: For worked examples in real life, can use a single table / array. Implementing as an array, wouldn't be able to mix string and integer data types easily without lots of unnecessary casting. Could use 2 lists or dictionariesOne for containing all unvisited nodesOne for containing all visited nodesAdd each node to a priority queue when its first discovered, once it has left it is then classed as visited.],
[Front: Measures of an algorithm's complexity Back: Time complexitySpace complexity Algorithms should aim to run as quick as possible and take up the least amout of space possible.],
[Front: Big O notation Back: Used to express the scalability of an algorithm as its order. Expresses the time complexity, or performace of an algorithm. Considers worst case scenario, assumes that every possible element is touched on as the algorithm executes.]"
"Understanding Big O Notation

Chapter 5: Introduction to Big O Notation
5.1 Basics of Complexity Analysis
- Importance of analyzing algorithm complexity
- Overview of time complexity and Big O notation

5.2 Constant Time Complexity - O(1)
- Definition of constant time complexity
- Examples and explanations of O(1) algorithms

5.3 Logarithmic Time Complexity - O(log n)
- Understanding logarithmic time complexity
- Examples and explanations of O(log n) algorithms

Chapter 6: Linear and Polynomial Time Complexity
6.1 Linear Time Complexity - O(n)
- Introduction to linear time complexity
- Examples and explanations of O(n) algorithms

6.2 Polynomial Time Complexity - O(n^2)
- Understanding polynomial time complexity
- Examples and explanations of O(n^2) algorithms

Chapter 7: Exponential Time Complexity
7.1 Exponential Time Complexity - O(2^n)
- Exploring exponential time complexity
- Examples and explanations of O(2^n) algorithms

Chapter 8: Practical Application and Analysis
8.1 Applying Big O Notation in Real-World Scenarios
- Evaluating algorithm complexity in practical situations
- Identifying potential performance bottlenecks

8.2 Choosing the Right Algorithm for Efficiency
- Comparing algorithms with different time complexities
- Making informed decisions based on efficiency analysis

Note: These textbook chapters provide thorough explanations and a comprehensive understanding of the concepts covered in the flashcards. Each chapter includes relevant examples and practical applications to facilitate learning and comprehension","[Front: Big O notation categories Back: O(1) - Constant timeO(log n) Logarithmic timeO(n) - Linear timeO(n^2) - Polynomial timeO(2^n) - Exponential time],
[Front: O(1) - Constant time Back: An algorithm that takes the same amount of them to execute regardless of the size of the input data set.  e.g. len(list) will take the same amount of them to execute no matter the number of items in the list.],
[Front: O(log n) Logarithmic time Back: An algorithm's time take to complete will grow very slowly as data set size increases.  e.g. Binary search is log base 2 n, doubling size of data set has very little effect on the time the algorithm takes to complete.],
[Front: O(n) - Linear time Back: An algorithm with the time to complete it grows in direct proportion to the data set size.  Performance declines as data set grows. Reduces efficiency with increasingly large data sets. e.g. Linear search list of 1000 items will take 1000 times longer than searching a list of 1 item.],
[Front: O(n^2) - Polynomial time Back: An algorithm where performance is directly proportional to the square of the data set size.  Significantly reduces efficiency with increasingly large data sets.  e.g. nested loops, e.g. of 3 nests = n^3, 4 nests = n^4.],
[Front: O(2^n) - Exponential time Back: An algorithm where time taken to execute doubles with every item added to the data set. Execution time growns exponentially.],
[Front: O(1) - Constant time example Back: len(list), returning the length of the list in the same time regardless of the number of items in it. print(list[0]) printing the first item of a list, will take the same time regardless of the number of items in the list.],
[Front: O(log n) - Logarithmic time example Back: Binary search algorithm With each pass, it halves the size of the input data set.],
[Front: O(n) - linear complexity example Back: Single for loops and while loops  Linear search],
[Front: O(n^2) - Polynomial time example Back: Nested for loops e.g. bubble sort and insertion sort]"
