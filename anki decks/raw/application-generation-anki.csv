#separator:tab
#html:false
Computer System subcategories:	HardwareSoftware
Hardware	All physical parts of a computer system and its relevant devices; both internal and external  e.g. Motherboard, HDD, RAM, monitors, keyboards, mice, printers etc
Software	General term covering all computer programs.
Categories of software	System Software Applications Software
Application Software Subcategories	General purpose softwareSpecial purpose softwareOff the shelfBespoke
General purpose software	No specific purpose. Carries out different tasks and meet multiple needs. Can be used for many different purposes. Product that allow users to be productive in multiple ways.  e.g. Word processor - can be used for tasks that can be fulfilled by bespoke software such as posters and flyers.  e.g. Graphics - package - used to produce advertisements or animations, manipulate photographs, draw vector or bitmapped images.
Special Purpose software	Perfrorms a single specified task or set of tasks. Other than its specified task, it has little more use. It takes the functionality of a general application further.  Tend to be only installed on systems if there is a need for it.  e.g. Payroll and accounts packages, hotel booking systems, fingerprint scanning systems. Database software. Although it may be highly specific, it is almost essential in creating a serious database in an application, its functionality could be copied in a spreadsheet sofware there would be limitations.  Off the shelfBespoke
Off the shelf	Ready to use application that could be bought straight away.  e.g. if a hotel wants to buy some visitor booking software they may be able to buy a ready made package that is suitable for their needs.
Bespoke	Custom made software with certain specifications and functionality fit to made the requirments of a customer.
Off the shelf vs Bespoke                 Off the shelfBespoke                 Less expensive since the cost is shared among all the other people buying the packageMore costly and requires expertise to analyse document requirementsMay contain a lot fo unwanted features, and some desireable but non essential features may be missingFeatures customised to user requirments and other features can be added as needs ariseReady to be installed immediatelyMay take long to developWell documented, well tested and error freeMay contain errors which do not surface immediately.	
Systems software	The software needed to run the computer's hardware and application programs. This includes the OS, utility programs, libraries and programming language translators.
Utility software summary	Sub category of system softwareSits alongside OSMany OS' come with utility software pre installedCan also be bought
Utility software is designed to:	Optimise the performance of the computer Keep computer safeProvide useful tools to manage files and applications
Types of Utility software	File RepairFile managementDevice DriversDefragmentationBack upsAnti malwareCompression
File repair software	Attempts to correct issues with damaged/corrupted files and restore them to its original working state. Often built in to applications but there can also be dedicated software found in OS' or even bought by vendors.
Back up software	Can be set up to manual, automatic or schedueled. Allows users to specify the destination of the back up, what you want to back up, how you want to run the back up (full back that zips the files, or mirror back ups that doesn't zip them)  Can be full or incremented back ups: Full is taking a copy of the selected files in their current state, each time. Takes up more storage.Incremented is only addind the new changes to a full back up. Back ups can be stored onto a different media or an offsite cloud system. Usually pre installed but can also be purchased.
Disk Defragmentation	A program that reorganises a magnetic hard disk so that files which have been split into blocks and stored all over the disk will be recombined in a asingle series of sequential blocks, making gile reading quicker. Puts fragments of files and free space back together. - Reduces the movment of the read/write head across the surface of the disk which speeds up file access as head is moving less.
How disk defragmentation works	Works be taking all the fragments of a file and puts them into a single file towards the end of the disk, reorganises them and puts them back together again. This frees up sufficient space at the start of the disk and them moves files back to the front. Resulting in that all the files are continuous, starting at the beginning of the disk and all the free space is at the end.
Why SSDs don't need to be defragmented.	They have no moving parts, data can be accessed from anywhere on the drive. Data can be accessed already quite quickly and it would reduce the SSD lifespan.
Automatic updating	Makes sure that any software installed on the computer is up to data. For any software already installed on the computer, the automatic update utility will regularly, check the Internet for updates. These will then be downloaded and installed if they are newer than the version already on the computer.
Why should firewalls and antivirus software must be updated regularly?	New viruses and threats are constantly being devised and discovered so making sure the computer has the most up to date software will help prevent them.
Why should application software should be updated	Previous versions may have bugs so updating the application will implement the bug fixes and improvements that become available to people with a license for that package.
Anti malware	Helps the computer and files safe from from many types of malware:  virusestrojans wormsspywareChecks the drive and depending on the level of protection, incoming emails and internet downloads are checked for viruses and removed.  Virtually all OS come with malware protection already built in, configureed and turned on.
Data compression software	Reduces the size of the file so it takes up less space in storage therefore downloads are faster over the internet. Compressed files must be extracted before they are read. Typically video files are compressed allowing them to be watched in real time and streamed and there would be to much data to transfer. Depending on the algorithm, data is either lost during compression thus reducing quality of the file Or data is represented in a different way using binary, retaining the original data in a new compressed format e.g. ZIP.
Open source software	Sofware is licensed for use but there is no charge for the license. Anyone can use it. Open source software must be distributed with the source code so anyone can modify it - may not be tested fully. Developers can sell the software they have created Any new software created from open source software must also be open meaning it must be distributed or sold in a form that other people can read and also edit.  Can be installed on any number of computers Support is provided by the community as a whole.
Open source benefits	Users get free software Wide feeling of modification from community Easy for creators to get their software to the community.
Open source drawbacks	There may not actually be much support for users  Some features might not be well tested or not integrated well Little to none financial gains for creators.
Freeware	Free software. Different to open source, software is free to use but user does not get access to source code and may have more restrictions.
Closed source	Closed soruce / proprietary softwate is sold in the form of a license to use it.  Protected by Copyright Design and Patents Act (CDPA) 1983. Users cannot modify software Usually paid for and users will have to have a license Supported by developer's who don't release source code. Tested prior to release by developers, although early access beta programs for further testing.
Benefits to closed source	User recieves a well supported, tested and a professionally built product. Creators receive an income for their work. Likely to be regular updates and technical support lines, trainign courses and a large user base.
Stages of compliation	Processors cannot run source code, it needs to be converted into machine code. During compilation process, a compiler runs through a series of parses. With each parse, the compiler performs different actions on the source code. Each parse is designed to carry out set tasks and prepare the code for the next stage in compilation.  Lexical AnalysisSymbol TableSyntax and semantic analysisCode generation and Code optimisation
Lexical Analysis	"Superfluous spaces are removed. e.g. print   (total_mark,    average) becomes print (total_mark,average)All comments, identifiers are removed from the program. Some simple error - checking is performed:Illegal identifiers would be flagged as errorsLexical analyser will detect an attempt to assign an illegal value to a constant, such as a value of the wrong type or the one that causes under/over flow.All keywords, constants and identifiers (e.g.  variable names) used in the source code are replaced by ""tokens"" (unique symbols). Numbers will be converted to their run time representation, and identifiers will be replaced by a pointer to an address in the symbol table. Keywords such as input, print will be replaced by a single item code."
Symbol Table	Contains an entry for every keyword and identifer in the program.  Format of entries in the table: identifer or keywordKind of item (variable, array, procedure, keyword)Type of item (integer, real, char etc)Run time address of the item, or its value if its a constantA pointer to accessing information ( e.g. for an array, the bounds of the array, or for a procedure, information about each of the parameters)Symbol table is usually organised as a hash table to have quick look up speeds which effect the speed of the compiler, keywords or identifer is hashed to produce an array subscript.
Syntax (and semantic) analysis	The process of determining whether the sequence of input characters, symbols, items or tokens form a valid sentence in the language. It analyses the syntactical structure of the input, checking if it is in the correct syntax. It does this by analysing the token stream against production rules to detect against any errors in code. Accomplishes: checking for errors and reporting thembuilding an abstract syntax tree (parse tree)The langugae has to be expressed as a set of rules, using syntax diagrams or Backus-Naur Form.
Parsing	The task of systematically applying the set of rules to each statement to determine whether it is valid.  Stacks are used to check that brackets are correctly paired, the priorities of airthmetic operators will be determined, and expressions converted ito a form ( reverse Polish notation) from which machine code can be easily generated.
Abstract syntax tree	Also known as parse tree.  Parse tree is created from the input token stream.  As the tree is created, it is strictly following the syntax diagrams to check if everything is correct. When an identifier is added to the abstract syntax tree, the symbole table is checked to see if it exists. The information from the parse tree can be used to update the datatype of indentifiers.
Semantics	Define the meaning rather than the grammer of the language: it is possilbe to write a series of syntactically correct statements which nethertheless do not obey the rules for the writing a correct program. An example of a semantic error is the use of an undeclared variable in Pascal, or trying to assign a real value to an integer variable, or using a real number instead of an integer as the counter in a for next loop
Code generation	When actual machine code is generated
Code optimisation	Attempts to reduce the execution time of the program by: spotting redundant instructions and producing object code that achieves the same as souce but by possibly different meansremoving subroutines that are never called.removing variables and constants never referenced.removing jumps in the program that perform no significiant task.
Disadvantages of code optimisation:	May increase compilation time.Can produce unexpected results.
Source code	Descriptive and easy to read, understand, maintain and debug for humans.
Translation	The process of converting source code to machine code so machines can execute binary instructions.
Types of translators:	assemblersinterpreterscompilers
Assembly code	Low level language Each instruction in assembly code almost always is eqiuvalent to one machine code instruction.  The instruction set of a computer are completely dependant on its hardware and therefore each different type of processor will have a different instruction set and a different assembly code.  Several low level code instructions are required to achieve the same result as a single line of high level code.
Assembler	A program that translates assembly code to machine code or an intermediate form called bytecode. The assembler progrram takes each assembly code instruction and converts it to the corresponding machine code instructions. The input to the assembler is cahlled the source code and the ouput (machine code) the object code.
Compiler	A program that translates a high level language into machine code. The source code is input as data to the compiler, which scan through it several times, each time performing different check and building up tables of information needed to produce the final object code then machine code.  It takes the entire source code and translates it, if successful, it will output machine code. After it has been translated to object code, a linker program pulls in any additional libraries that may be needed. Then either the machine code is produced or intermediate code is created to then be interpretted in executable machine code. Different hardware platforms require different compilers since the resulting object code will be hardware specific. Object code can then be saved and run whenever needed without the presence of the compiler.
Interpreter	Program that translates high level code into machine code Takes one line of source code, analyses it and if it does not contain any syntax errors, translates it and then executes it.
Advantages of compiler over interpreter	Object code can be saved on disk and run whenever required without the need to recompile Object code executes faster than interpreted code The object code produced by a compiler can be distributed or executed without having to have the compiler present The object code is more secure, as it cannot be read without a great deal of reverse engineering
Applications of compiler	Appropriate when a program is to be run regularly or frequently, with only occasional change. Also appropriate when the object code produced by the compiler is going to be distributed or sold outside the company that produces the software, since the source code is not presented and therefore cannot be copied or ammended.
Advantages of an interpreter over a compiler	Platform independance - the source code can be run on any machine which has the appropriate interpreter available (e.g. Java's byte code) It is useful for program development as there is no need for lengthy recompilation each time an error is discovereed
Disadvantages of interpreter	Program may run slower than compiler program becuase each statement has to be translated to machine code each time is encountered. So if a loop of 10 statements is performed 20 times all 10 statements are interpreted 20 times.
Bytecode	Intermediate represetation which combines compiling and interpretting. Byte code is then executed by a bytecode interpreter. Byte code may be compiled once and for all as in Java or each time a change is made in source code is detected before executed as in Python.
Advantages of bytecode	Platform independance - any computer that can run Java programs has a Java Virtual Machine. Extra security layer between computer and program - download an untrusted program and you then execute the bytecode interpreter rather than the program itself, guards the computer against malicious programs Can compile from different langauges, e.g. Python into Java bytecode  (using Jython compiler) and then use the Java interpreter to interpret and execute it.
Java virtual machine	A piece of software which masks inherent differences between different computer architectures and operating systems. The JVM understands bytecode and converts it into the machine code for that particular computer.
Operating system	set of programs that lies between applications software and the computer hardware and has different functions: resource management - managing all the hardware including CPU, memory, disk drives, keyboard, monitor, printer and other peripheral devicesProvision of a user interface to enable users to perform tasks such as running application software, changing settings on the computer, downloading and installing new software, etc.
Libraries	Readily compiled and tested programs that can be run when needed. Typically grouped together in software libraries. Most programming languages have extensive libraries of pre written functions which can be invoked in a defined manner from within the user's program.
Dynamic Link Libraries	Windows OS libaries that contain subroutines written to carry out a common task on the Windows OS, e.g. Save As where the user needs to save their work as a file. .dll extension
Benefits of Libraries	"Quick and easy to use and hook into your own code. Pre tested and can be relatively sure they are error free. Pre compiler so typically optimised to run quickly. Save the programmer time in ""re inventing the wheel"" to write code themselves to perform common tasks."
Drawbacks of libraries	Adding functionality / making changes to libraries can be impossible. Understanding actual implementation, you have no idea how the library works. You have to trust the developers to maintain the library.
Linkers	Responsible for putting the appropriate machine addresses in all external call and return modules and external library routines are linked together correctly.  Links seperately compiled subroutines into object code.
2 methods of linkers pulling libraries:	Static linking Dynamic linking
Static linking	All the required code from libraries is included in finished machine code - resulting in a large executable file
Dynamic linking	Compiled versions of the required libraries are stored on the host computer. The OS links the required code from the library as the program is running This cuts down the size of the compiled machine code If the dynamic libraries change the program may stop as it trying to call a subroutine in the wrong way.
Loader	Part of the OS that loads the executable program into memory to be ready to run. When using dynamic linking it will also be responsible for loading the required libraries into memory. Relocating loader can load the object code anywhere in memory providing that the programmer has no absolute addresses and the object code is in relocatable format.
