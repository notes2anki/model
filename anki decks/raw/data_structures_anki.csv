#separator:tab
#html:false
Array	A finite, ordered set of elements of the same type such as integer, real or char. Allocates a contiguous part of memory to store the data. Finite meaning there is a specific number of elements in the array, ordered meaning that there is a 1st, 2nd, 3rd, ... element in the array. Indexing can be used to easily access or reference the data.
Multidimentional arrays	Array's can 2 or more dimensions. A 2 dimensional array can be visualised as a table, with 2 sets of indexes, one for rows, one for columns. A 3 dimensional array can be visualised as a cube. An n dimensional array is a set of elements of the same type indexed by n integers.
Record	A collection of related fields. A field contains one data item, and each field in a record can have different data types. Usually used in database files that hold a number of records.
How to use a record data structure	Define the record structure, what fields are in the record.Declare a variable or array to use with the record structure.Assign and retrive data from record variable record.
List	Abstract data type consisting of a number of items which the same item may occur that once. Lists are indexed so they can be refered to the nth item. Same data type. List is useful data type for a wide variety of operations and can be used to implement other data structures such as queues, stack or tree. Python has a build in list data type.
Static data structure	Structure size cannot be changed at run time. Fixed in size, cannnot increase in size or free up memory while program is running. e.g. Array.
Dynamic data structure	Structure size can change at run time. Refers to a collection of data in memory that has the ability to grow or shrink in size, achieves this with the heap which is a portion of memory from which space is automatically allocated or deallocated as required.
Mutable	Structure / data can be change at run time.
Immutable	Structure / data cannot be changed at run time.
Tuple	Ordered set of values, which could be elements of any type such as strings, integers or real numbers or even graphic images, sound files or arrays. Elements do not have to be all of the same type. Immutable, elements cannot be changed. Cannot dynamically add elements to or delete elements from a tuple. Similar to lists but are of a fixed size.
Difference between lists, array and tuples.	List​Array​Tuple​                 ​DynamicStatic​Static​​MutableMutable​​Immutable​Ordered collection of items​Ordered collection of items​Ordered collections of items​Items can be changed or replacedItems can be changed or replaced​Items cannot be changed or replaced​​Can store more than one data typeOnly one data type​More than one data type​
Linked list	Dynamic data structure used to hold an ordered sequence of items. Items in the list are not necessarily held in contiguous data locations or in the order in which they occur in sequence. Each item in the list is called a node and contains a data field and link / pointer field that points to the address of the next node. Data field contains the actual data associated with the listed item.
Doubly linked list	Where nodes can point to both the previous and next node with an extra pointer.
Circular linked list	Made by making the last node contain a pointer to the first node.
Circular doubly linked list	Circular linked list where each node has additional pointers to previous nodes.
Implementing linked lists using a static array	Linked lists can be implemented using static arrays. As static, arrays stored contiguously in memory, requiring use of index register to determine where a specific index is in relation to a base address.
Implementing linked list using objects	With linked list that uses objects, any available memory address can be used to store data. Does not need to be adjacent as each node points to next in the structure. The memory foot print of the data is not determined at compile time and can changed dynamically at run time.
Applications of linked list	Used by OS' managing a process to store process blocks in a ready state. Image viewers to switch between previous and next images. Audio players to store tracks in a playlist. Web browsers to navigate backwards and forwards. Used for hash table collision resolution as an overflow. Maintaing a file allocation table of linked clusters on secondary storage.
Operations on linked list.	Add nodes Delete nodes Next item in a list Previous item in doubly linked list Traverse: linear search through a linked list.
Graph	Data structure which is a set of nodes / vertices connected by pointers / edges / arcs.
Undirected graph	All edges / arcs / pointers are bidirectional.
Directed graph	Edges / arcs / pointers are in one direction.
Weighted graph	Graph edges with a given value representing a relationshop between nodes. e.g. the distance between towns.
Implementation of graphs	Adjacency list Adjacency matrix
Adjacency matrix	2 dimensional arrays can be used to store information about a directed or undirected graph. Rows and columns represented the nodes and and the intersecting cell contains the value of edge weighting. For unweighted graphs, cells contain 1. Intersecting cells where there is no direct connection between nodes are left empty.
Advantage of adjaceny matrix	Convenient to work with, easy to add the edges.
Disadvantages of the adjacency matrix	If a graph is sparsely populated with many nodes with not many edges will mean many cells will remain empty, the larger the graph, the more memory space will be wasted. Using a static 2D array will be harder to add to delete nodes.
Adjacency list	A list of all the nodes is created, and each nodes points to a list of all the adjacent nodes to which it is directly linked. Implemented as a list of dictionaries, with the key in each dictionary being the node and the edge weight.  Unweighted graph would not have the weight.
Advantage of adjacency lists	More space efficient way to implement a sparsely connected graph that it would be with a matrix.
Uses of graphs	Mapping road networks for navigation systems Social media network data Resource allocation in OS Representing molecular structures and geometry.
Abstraction of graphs	May look different but can be the same as long as they have the same nodes and connected in the same way. Using only necessary detail and discarding unnessary details. e.g.  Navigation systems only need to know each road's type and length and connections. Such as London underground map, doesn't actually show where stations are physically located by shows which stations are connected to which lines.
Standard Operations on a graph	Adjacent - Returns whether if there is an edge between 2 nodes Neighbours - Returns all the nodes between 2 nodes Add - Add new node to a graph Remove - A node from a graph Add new edge - Add new edge to connect 2 nodes Remove edge - Removes an edge between 2 nodes Get node value - Returns value in node Set node value - Sets data for a node Get edge value Set edge value
Search operations on graphs	Depth first search - Starts at root node, visits each node and explores each branch as far as possible before backtracking Breadth first search - Starts at root node and visits each neighbouring node, before moving to nodes at next depth.
Traversal operations on graphs	Pre order  In order Post order
Stack	Data structure is essential for operations of a computer. Last In First Out structure - stacks can only be added to from the top and removed from the top. Stack has stack pointers that always point to node on top. Stores information about the active subroutines while a computer program is running. Details are hidden from the user in all HLL.
Stack operations	Push  - items added onto the top of the stack Popped - items from the top of the stack taken off / deleted. Peek - To see the top without removing it.
Stack overflow	Pushing an item ontop of a full stack
Stack underflow	Attempts to pop item of an empty stack.
Implementation of stack	Either as static or dynamic data structure. Often implemented using an array, used with 2 additional variables, one used as a pointer to the top of the stack, other holds the maximum size of the stack. Can also created using object orientiation.
Applications of stacks	Performing depth first searches on graph data structures. Keeping track of user inputs for undo operations. Back tracking algorithms e.g. path finding maze solutions. Evaluating mathematical expressions without brackets using a shunting algorithm and reverse Polish Notation.
Call stack : holding return addresses	Call stack keeps track flow of programs by a processor. Keeps track of the address of the instruction that control should return to when a subroutine ends (return address). Several subroutines may be nested, so that the stack may contain several return addresses which will be popped as each subroutine completes. When a subroutine is called, it changes the value of the program counter to the first instruction of the new subroutine, the value held in the PC originally is pushed onto the stack and when the new subroutine ends, the original PC value, the return address is popped back into the PC. A recursive subroutine may have many calls to itself, so with each call, a new return address is pushed onto the stack. When the recursion ends, the return addresses that have been pushed onto the stack each time is called and popped one after the other, each time the end of the subroutine is reached. If the recursion never ends, memory will run out and the stack will overflow and the program will crash.
Call stack : holding parameters	Parameters required for a subroutine may be held on the call stack. Each all to a subroutine will be given seperate space on the call stack for these values.
Call stack : local variables	The call stack many also contain local variables frequently used by a subroutine so they are accessible and useable only within the subroutine. Each seperate call to a subroutine gets its own space for its local variables in the call stack. Storing local variables on the call stack is much more efficient than using dynamic memory allocation, which uses heap space.
Stack frame	Call stack is composed of stack frames. Each stack frame corresponds to a call to a subroutine which has not yet terminated.
Abstract Data Type	One created by the programmer, rather than defined within the programming language. Include, queues, stacks, trees and graphs.  Logical description of how data is viewed and how the operations that can be performed on it. The way this is done is not necessarily known to the user.  It is an example of data abstraction and providing this level of abstraction we create an encapsulation around the data, hiding the details of implementation from the user.
Queue	First In First Out data structure. New elements can only be added to the end of the queue, elements can only be retrieved from the from of the queue. Sequence of a queue is determined by the order elements are inserted in. Size of queue depends on number of elements in it. Back / tail pointer always pointing to the last item. Front / head pointer pointing to the first item.
Queue operations	enQueue - add a new item to the back of the queue deQueue - removes the front item from the queue and return it peak - returns the item at the front of the queue without removing it isEmpty - returns true if the queue is empty isFull - returns true if the queue is full
Queue applications	Printing queues, the order in which computers on a network send print jobs to a printer, that is the order they will come out in. Characters typed at a keyboard are held in a queue in a keyboard buffer. Simulation problems, e.g. supermarket check outs. Processor schedueling Breadth first searching on graphs.
Queue overflow	enQueueing to a full queue
Queue underflow	deQueueing to an empty queue.
Queue implementation	Using arrays, lists or object oriented methods. 1. As item leaves queue, all of the other items move up one position in allocated memory so that the from of the queue is always the first element of the structure. With long queues, this may require significant processing time. 2. As an array with pointers to the from and rear of the queue. An variable is needed to hold the size of the array, max queue length, and a variable is needed to hold the number of items currently in the queue. This has a problem of when many items are added to and deleted from the queue, as space is creared at the front of the queue which cannot be filled, and items are added until the rear pointer points to the last element of the data structure.
Circular queue	As arrays are static, both the back and front pointers move in the same direction as items are added and removed fromt the queue which could result in the queue running out of space. Solution is to cycle the back pointer to the front of the array when it reaches the end assuming this element is empty. Ideal if you want to restrict the number of items and have a known memory foot print. Useful for game designs where number of sprites on screen affects frame rate. By only spawning sprites up to the limit of the queue, stable frame rate achieved. Requires effort from programmer and is less flexible than a dynamic data structure if the max number of items is not known in advance.
Pseudocode for implementing a circular queue	
Priority queue	When queue system allows for elements to go join the queue ahead of other elements, usually at the front. Acts like a queue in that items are dequeued by removing them from the front of the queue but the logical order of ithems within the queue is determined by their priority, with the highest priority at the front of the queue and lowest at the back. Used in processor schedueling. Could be implemented by checking priority of each item in the queue, starting at the rear and moving along one place until an item with the same or lower priority is found, at this point the new item can be inserted.
Heap	A portion of memory from which space is automatically allocated or deallocated as required.
Dynamic data structure advantages	Useful for implemeting data structures such as queues when the max size is not known in advance. Queue can be given some arbitrary maximum to avoid causing memory overflow but it is not necessary to allocate this space in advance. Built in dynamic data structures such as a list is that many methods or functions such as append, remove, length, insert, search and pop may already be written and can be used in the implementation of the other data structures such as a queue or stack.
Static data structures disadvantages	Using a static data structure to implement a dynamic data structure such as queue is that size of the array has to be decided in advance by programmers and if number of items added fills up the array, then no more can be added regardless how how much free space there is in memory.
Trees	Consists of nodes and pointers / edges. Each tree has a root node which is at the top. Nodes are connected with pointers / edges. Each node apart from the root node is connected to exactly one node. Special case of connected graph. Nodes can only be connected to their parent and children. Has no cycles because there is no connection between children or branches.
Root node	Node with no incoming edges
Child node	Set of nodes that have incoming edges from the saem node
Parent node	A node of all the nodes it connects to with outgoing edges.
Leaf node	A node with no children.
Subtree	Set of nodes and edges comprised of a parent and all descendants of the parent.
Uses of rooted trees	Storing and managing files and folder structures. Implementation of the A* pathfinding algorithm. Manipulating sorted lists of data. Making information easy to search (binary search tree). Storing and manipulating any form of hierarchal data that requires a parent node to have 0,1 or more child nodes e.g. family tree, corporate structures.
Binary search tree	Similar to standard tree data structure. Special case of a graph where each node can only have 0,1 or 2 pointers which each pointer connecting to different nodes. Nodes can have a maximum of 2 children. Holds items in such a way that the tree can be searched quickly and easily for a particular item, new items can be easily added and the whole tree can be printed out in sequence.
Implementation of binary trees	Using an array of records, each node consisting of: left pointerdata itemright pointerCould also held in a list of tuples, or 3 seperate lists or arrays, one for each of the pointers and one for the data items. More common to see the binary trees represented as objects, nodes with left and right pointer and if no child node: left and right pointer - null.
Constructing a binary search tree	Place the first item at the root.Then for each item in the list, visit the root, which becomes the current node, branch left if item is less than the current node, right if item is greater than value at current node.Continue down the branch applying the rule at each node visited, until a leaf node is reached.The item is then placed to the left or the right of this node depending on whether it is less than or greater than the value at the node.
Binary search tree construction	
Hashing algorithm	An algorithm that is applied to a value in the key field of each record to transform it into an address. Common algorithm is to divide the key by the number of available addresses and take the remainder as the address.
Hashing synonyms and collisions	When a hashing algorithm returns the same address for different keys.
Hash table	Colleciton of items stored in such a way that they can be quickly located. Hash table can be implemented as an array or list of a given size with a number of empty spaces.
Searching (traversing) for an item in a hash table	Apply the hashing algorithm to the key field of the item Examine the resulting cell in the list If the item is there, return the item If the cell is empty, the item is not in the table If there is another item in that spot, keep moving forward until either the item is found using a collision resolution strategy or a blank cell is encountered, when it is apparent that the item is not in the table.
Collision resolution strategies : rehashing	Next available space Open adressing Linear probing 2 dimentional hash table
Next available space	Place the item in the next available empty space.
Open addressing	Where repeatedly check for the next available space in the hash table is found and stored there.
Linear probing	To find the item later, function delivers the start position from which a linear search can then be applied until the item can be found.
Linear probing disadvantage	Prevents others items from being stored at their correct locations Also results in clusterig where several positions being filled around common collusion values.
Rehashing indepth	Looks for an available space by looping round the first cell if the table of the end is reached. Look at every third cell, plus 3 rehash. Hash value could be incremented by 1,3,5,7 until a free space is found
Hashing algorithm trade off	Trade off between efficiency of the algorithm and size of the hash table.
2 Dimensional hash table	Allows for chaining - more than one 1 item placed in the same y position. Over flow table which can then be searched sequentially. Linked list to maintain overflow - search sequentially.
Hash tables applications	Where items in a large data set need to be found quickly File systems linking a file name to a file path Identifying the key words in a programming language during compilation. Efficient lookup. Used to store user codes and encrypted passwords. Used in implementation of dictionaries, used for implementing graphs.
Dictionaries	Consists of pairs of items, where each pair consists of a key and a value.  When user supplies the key, associated is returned. Items can be amended, added to or removed from dictionary as required.
Hashing algorithms: Folding	Divides the item into equal parts and adds the parts to give the hash value. e.g. A phone number can be divided into groups of 2, then add together.
Operations of a hash table	Add items Remove items Retrive items using its hash value
Hashing a string	Using the ASCII code for each character. Add up the ASCII values, divide by the spaced in the hash table and take the remainder as the hash value.
Operations on dictionaries	Possible to implement using either a static or a dynamic data structure.  Create a new empty dictionaryAdd a new key:value pair to the dictionaryDelete a key:value pair from the dictionaryAmend the value in a key:value pairReturn a value associated with key kReturn True or False depending on whether key is in the dictionaryReturn the length of the dictionary, the number of key:value pairs.
Initialsing a linked list	2 Link lists are required to be kept. One for actual data and one for the free space. When a new item is added, it is put in the node pointed to by nextfree. When a node is deleted it is linked into the free space list. Array is initalised prior to entering any data and it will consist of just one linked list of free space. After initialisation, nextfree points to the first free space in the list, Data[0].  A pointer named start will point to the first data item in the list, which will be initialised to null, indicating the list is empty. Last item in the free space list also has a pointer of null indicating that this the last available free space in the list.  There are 2 linked lists, list linking the nodes containing the data and the list linking the free nodes. A pointer start points to the first item in the list nextfree is a pointer to the next free location in the array. The free spaces in the array are orgranised as a linked list. Data can be retrieved in order by following the links.  If we were to use objects to implement this linked list, we would not need the free space linked list.
Adding an item to a linked list	Check if there is free memory for a new node. Output error if not. Create a new node and insert data into it / insert data in the node indicating by the nextfree pointer. If we were to use object oriented approaches, we wouldn't need the free space list.If the linked list is empty:New node becomes the first item. Create a start pointer to it.If the new node should be placed before the first node:The new node becomes first node. Change the start pointer to it.The new node points to the second node.If new node is to be placed inside the linked list:Start at the first nodeIf the data in the current node is less than the value of the new node:Follow the pointer to the next nodeRepeat from step 5.2 until the correct position is found or the end of the linked list is reachedNew node is set to point where the previous node pointed.The previous node is set to point to the new node.Update the nextfree pointer so it point to the next available storage space.
Psuedocode algorithm for inserting an item, handling special case of full lists, and inserting item to front of the list.	
Deleting an item from a linked list	Check if the linked list is empty and output an error if there is no start nodeIf the first item is the item to delete, set the start pointer to point to the next node.If the item to delete inside the linked list:Start at the first node.If the current node is the item to delete:The previous node's pointer is set to point to the next node.Follow the pointer to the next node.Repeat from step 3.2 until the item is found or the end of the linked list reached.Update the nextfree pointer. Note how the item is not actually deleted from the array just that the node doesn't point to anything and no nodes point to it. If we want to add a new item, we just overwrite the node and update pointers.
Simplified algorithm to add data to a linked list.	
Simplified algorithm to delete an item from a linked list	
Pseudocode algorithm for deleting an item	
Traversing a linked list	Check if the linked list is empty - if it is return an errorStart at the node the start pointer is pointing to.Output the item.Follow the pointer to the next node.Repeat from step 3 until end of the linked list has been reached.
Adding an item to a graph	No set algorithm for it because a graph can have any number of nodes connected other nodes. Depends on the graph you are using and the item you want to add. The algorithm needs to be able to easily traverse the graph in order to find a specfic node that the new node connects to.
Removing an item from a graph	No set algorithm for it because a graph can have any number of nodes connected other nodes. Depends on the graph you are using and the item you want to remove. The algorithm needs to be able to easily traverse the graph in order to find a specfic node and remove its edges..
Ways to traverse a graph	Depth first Breadth first
Breadth first search	Node based method of finding the shortest path to a node through a graph.  Makes uses of a queue data structure and its FIFO method. One node at a time is selected, visited and marked. Then adjacent nodes are visited and stored in a queue. Set the root node as the current nodeAdd the current node to the list visited nodes if not already in the list.For every edge connected to the current node:If the linked node is not in the visited list:enQueue the linked nodeAdd the linked node to the visted list.deQueue an item and set it to the current node.Repeat from step 2 until queue is empty.
Depth-first search	Edge based technique Makes use of the stack data structure using its LIFO method. 2 main stages: Visited nodes are pushed onto the stackWhen there are no nodes left to visit, the nodes are poppe of the stack. Go as far down one route as we can before backtracking and taking the next route.   Set the root node to the current node.Add current node to the list of visited nodes if it isn't already in the list.For every edge connected to the current node:If the connected node is not in the visited list, push the linked node onto the stack.Pop the stack and set the item as the current node.Repeat from step 3 until there are no nodes left to visit.Output all the visited nodes.
Recursive approach to depth first	Simplifies the algorithm. Set root node to current node.Output the node.Add the current node to the list of visited nodes.Follow the edge. The node becomes the current node.Repeat from step 2.
Graph traversal summary.	​Breadth first search​Depth first search                 Uses a queue to find shortest path through an unweighted graph.​​Uses a stack.Read a node with the minumum number of edges from the so​urce node.May traverse through more edges to reach a destination node form a source.​More suitable for searching nodes that are closer to the source.​More suitable for when there are solutions further away from a source.​Considers all neighbours first, so isn't suitable for decision making trees used in games or puzzles.​​More suitable for games or puzzle problems. We make a decision, then explore all paths through that decision. If the decision leads to a win situation, we stop.
Adding an item to a stack (push) using an array	Push operation, push the new item onto the top of the stack. Check for stack overflow. Output an error if the stack is full. We are using an array to implement our stack, static data structure so has limited number of spaces to store items.Increment the stack pointer so it points to the next available space in the array.Insert the new data item at the location pointed to by the stack pointer. Step 2 and 3 can be swapped around.
Adding an item to a stack (push) using objects	Gets around the restrictions of a static array. Stack can grow and shrink dynamically to any size assuming we have enough memory. Check for stack overflow. Output an error if no free memory is available.Create a new node and insert data into it.The new node points to the previous node.Stack pointer is set to point to the next node.
Psuedocode function for checking if a stack is empty	
Psuedocode function to check if stack is full.	
Psuedocode function to push an item on a stack	
Adding an item to a queue (enqueue)	Check for queue overflow. Output an error if the queue is full.Increment the back / tail pointer so it points to the next available space in the array. Moves because new items are always enqueued at the back of the queue.Insert the new data item at the location pointed to by the back / tail pointer. Steps 2 and 3 could be swapped around.
Adding an item to a queue (enqueue) using objects.	Queue can grow or shrink dynamically to any size providing sufficient memory. Check for queue overflow. Output an error if no free memory is available.Create a new node and insert data into it.The back pointer is set to point to the new node.If this is the first in the list, the front pointer is set to point to the new node.
Removing an item from a stack(pop)	Popping the last item added from the top of the stack. Check for stack underflow. Output an error if the stack is empty.Copy / output the data item pointed to by the pointer.Decrement the pointer. Steps 2 and 3 can be swapped. The data value is not actually physically deleted, just the pointers have been adjusted so that is not pointing to or from other items.
Removing an item from a stack(pop) using objects	Check for stack underflow. Output an error if the stack pointer does not point to a node.Output the node pointed to by the stack pointer.Set the stack pointer to the previous item.
Removing an item from a queue(dequeue)	Dequeueing the item at the from of the queue. Check for queue underflow. Output an error if the queue is empty.Copy / output the data item pointed to by the front / head pointer.Increment the front / head pointer.  Data point removed still exists just has no pointers to it or anything it points to, effectively removing it from the data structure.
Removing an item from a queue(dequeue) using objects	Check for queue underflow. Output an error if the front pointer does not point to a node.Output the node pointed to by the front pointer.Set the front pointer to the previous item.
Psuedocode to remove(pop) an item from a stack	
Traversing stacks and queues	No operations that will expose elements in the middle. Can only peek to look at the top of front of data structure. Or repeatedly pop or dequeue items.
Psuedocode to initialise a circular queue	
Psuedocode to check for an empty circular queue	
Psuedocode to check for a full circular queue	
Function to add element to a circular queue	
Pseudocode to remove an item form a circular queue	
Adding an item to a binary tree OOP approach	Check if there is free memory for a new node. If not then output an error.Create a new node and insert data into it.If binary tree is empty:New node becomes first item, root node. Create a start pointer to it.If the binary tree is not empty:Start at the root nodeIf the new node should be placed before the current node, follow the left pointer.If new node should be placed after the current node, follow right pointer.Repeat 4.2 and 4.3 till until a leaf node is reached.If the new node should be placed before the current node, set the left pointer to be the new node.If the new node should be placed after the current node, set the right pointer to be the new node.
Removing an item from a binary tree	First find the node we want to delete. Start at the root node and set it as the current node.While the current node exists and is not the one to be deleted:Set the previous node variable to be the same as the current node.If the item to be deleted is less than the current node, follow the left pointer and set the discovered node as the current node.If the item to be deleted is greater than the current node, follow the right pointer and set the discovered node as the current node.If leaf node:If the previous node is greater than current node, previous node left pointer set to null.If previous node is less than the current node, previous node right pointer is set to null.If node has 1 child:If current node is less than previous node:Set previous node left pointer to current nodes left child.If current node is greater than previous node:Set the previous nodes right pointer to the current nodes right child.If node has 2 child (using Hibbard deletion):If a right node exists and it has a left sub tree, find the smallest leaf node in right sub tree:Change current node to smallest leaf node.Remove smallest leaf node.If right node exists and has no left left subtree:Set current node to be the current nodes right pointer.Set current node's right pointer to null.
Alternative method to deleting items from binary tree	Introduce another attribute to each node that flags when a node is deleted. These deleted nodes are then skipped when traversing the tree. This would simplify pseudocode but increase space time complexity as nodes are added and deleted. Eventually could end up with over half the nodes in our binary tree flagged as deleted. Inefficient.
Ways to traverse a binary tree	Pre orderIn orderPost order They output data differently.
Pre order traversal	Variation of depth first search used to create a copy of a binary tree or return prefix expressions in Polish notation which can then be used by programing language interpreters to evaluate syntax. Desribed as node-left-right: Start at root nodeOutput the nodeFollow the left pointer and repeat from step 2 recursively until there is no pointer to followFollow the right pointer and repeat step 2 recursively until there is no pointer to follow. Draw an outline around the tree structure starting to the left of the root. As you pass to the left of a node, output the data in that node.
Psuedocode for pre order	Visit the root node  Traverse left sub tree Traverse right sub tree
Pre order uses	Producing a prefix expression from an expression tree. Prefix is usef in some compilers and calculators.
In order traversal	Variation of depth first used to output contents of binary tree on order. Automatically sorts contents of structure without moving, data irrespective of the order in which the data arrived. Negates the need for an insertion sort. left-node-right: Start at root nodeFollow the left pointer and from step 2 recursively until there is no pointer to follow.Output the nodeFollow right pointer and repeat from step 2 recursively until there is no pointer to follow. Draw an outline of the tree structure, starting to the left of the root. As you pass underneath a node, output the data in that node. In order traversal visits nodes in sequential order.
Pseudocode for inorder	Traverse the left subtree Visit the root node Traverse right subtree
Uses of in order	Perform an efficient serach for any item.
Post order traversal	Variation of depth first search used to delete a binary tree. Also useful to output post fix expressions, to be then used to evaluate mathematical expressions without the need for brackets - how ALU work in stack machine computers and was used in pocket calculators until early 2010s. left-right-node: Start at the root nodeFollow the left pointer and repeat from step 2 recursively until there is no pointer to follow.Follow the right pointer and repeat from step 2 recursively until there is no pointer to follow.Output the node. Draw an outline around the tree structure, starting to the left of the root. As you pass to the right of a node, output the data in that node.
Psuedocode for post order traversal	
Uses of post order	Variation of depth first search used to delete a binary tree. Also useful to output post fix expressions, to be then used to evaluate mathematical expressions without the need for brackets - how ALU work in stack machine computers and was used in pocket calculators until early 2010s. Used to write in Reverse Polish Notation which is used by compilers to evaulate expression.
Adding an item to a hash table	Calculate the position of the item in the hash table using a hashing functionIf the calculated position is empty, insert the item and stop.If there is a collision, check the first position in the overflow table (or rehash):If the position is empty, insert the item and stopIf not empty, increment the position to check in the oveflow table.Repeat from step 3.1 until the item is inserted or the overflow table is full.
Removing an item from a hash table	Calculate the position of the item in the hash table using a hashing function.If the calculated position contains the item to be deleted, delete it and stop.If the calculated position doesn not contain the item to be deleted, check the first position in the overflow table (or rehash):If the position contains the item to be deleted, delete it and stop.Increment the position to check in the overflow tableRepeat from step 3.1 until the item to delete is discovered or the end of the overflow table is reached. Item may not actually be physically deleted but the address is marked as available for used and will be overwritten later.
